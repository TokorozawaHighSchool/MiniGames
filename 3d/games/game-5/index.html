<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Forest FPS MVP</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div id="overlay">
  <button id="startBtn">クリックして開始（Pointer Lock）</button>
  <button id="fullscreen-toggle" aria-label="フルスクリーン切替" style="margin-left:8px">⤢</button>
  <div id="hint">WASD 移動 ・ マウスで視点 ・ クリックで射撃 ・ Shiftでダッシュ（スタミナ消費・自動回復） ・ Mでマップ</div>
  </div>
  <div id="hud" style="position:fixed;left:12px;top:12px;color:#022;font-weight:700;background:rgba(255,255,255,0.85);padding:6px 10px;border-radius:6px">Score: <span id="score">0</span>
    <div id="coords" style="font-weight:400;margin-top:6px;font-size:12px">x:0.00 y:0.00 z:0.00</div>
  </div>
  <!-- Stamina bar (top center) -->
  <div id="stamina-wrap" style="position:fixed;left:50%;transform:translateX(-50%);top:8px;width:40%;max-width:600px;">
    <div style="background:rgba(0,0,0,0.55);padding:6px;border-radius:8px;color:#fff;font-size:13px;text-align:center">Stamina</div>
    <div style="background:rgba(0,0,0,0.25);height:10px;border-radius:6px;margin-top:6px">
      <div id="stamina-bar" style="height:100%;width:100%;background:linear-gradient(90deg,#7cf,#06f);border-radius:6px;transform-origin:left"></div>
    </div>
  </div>
  <!-- Health (bottom-left, large rectangular bar, no label) -->
  <div id="health-wrap" style="position:fixed;left:12px;bottom:12px;z-index:9999;">
    <div id="health-bar-wrap" style="position:relative;background:rgba(255,255,255,0.95);height:28px;border-radius:2px;margin-top:0;width:420px;box-shadow:0 3px 8px rgba(0,0,0,0.35);outline:1px solid rgba(0,0,0,0.25)">
      <div id="health-bar" style="height:100%;width:100%;background:#d33;border-radius:2px;transform-origin:left;transition:width 0.08s linear"></div>
      <div id="health-text" style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-size:14px;color:#111;font-weight:800;text-shadow:0 1px 1px rgba(255,255,255,0.7)">100 / 100</div>
    </div>
  </div>
  <script type="module">
// game-5 urban step1: asphalt ground + roads, overcast mood
(async function(){
  let THREE;
  try {
    THREE = await import('./lib/three.module.js');
  } catch(errModule){
    console.warn('Local three.module.js import failed:', errModule);
    const tryLoadLocalUMD = () => new Promise((resolve)=>{
      const path = './lib/three.min.js';
      const script = document.createElement('script');
      script.src = path;
      script.onload = () => resolve(window.THREE ? window.THREE : null);
      script.onerror = () => resolve(null);
      document.head.appendChild(script);
      setTimeout(()=>{ resolve(window.THREE ? window.THREE : null); }, 1500);
    });
    const localUMD = await tryLoadLocalUMD();
    if(localUMD){
      THREE = localUMD;
    } else {
      console.warn('Local UMD not found or failed; falling back to CDN module');
      THREE = await import('https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js');
    }
  }
  const { Scene, PerspectiveCamera, WebGLRenderer, Color, FogExp2, DirectionalLight, AmbientLight, HemisphereLight, PlaneGeometry, MeshStandardMaterial, Mesh, Vector3, CanvasTexture, CylinderGeometry, InstancedMesh, PointLight, BoxGeometry, BufferGeometry, Points, PointsMaterial, Group, ConeGeometry, MeshBasicMaterial, DoubleSide, ShaderMaterial } = THREE;

  // scene & renderer (2:00 AM horror ambience)
  const scene = new Scene();
  const skyCol = new Color(0x0a0c12); // deep night blue-black
  scene.background = skyCol;
  scene.fog = new FogExp2(0x0b0d14, 0.008);

  const camera = new PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 6000);
  camera.position.set(0, 1.6, 10);

  const renderer = new WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  // lights (moody night)
  const hemi = new HemisphereLight(0x223040, 0x05070a, 0.22);
  scene.add(hemi);
  const sun = new DirectionalLight(0xcfe5ff, 0.22); // moonlight
  sun.position.set(-120, 160, -60);
  sun.castShadow = true;
  sun.shadow.mapSize.set(1024,1024);
  sun.shadow.camera.near = 0.5; sun.shadow.camera.far = 600;
  sun.shadow.camera.left = -200; sun.shadow.camera.right = 200; sun.shadow.camera.top = 200; sun.shadow.camera.bottom = -200;
  scene.add(sun);
  scene.add(new AmbientLight(0x304050, 0.08));

  // helpers: canvas textures
  function makeNoiseCanvas(w=512, h=512, base=68, amp=14){
    const c = document.createElement('canvas'); c.width=w; c.height=h;
    const ctx = c.getContext('2d');
    const img = ctx.createImageData(w,h);
    const d = img.data;
    for(let i=0;i<w*h;i++){
      const n = base + Math.floor((Math.random()*2-1) * amp); // grey with noise
      const o = i*4; d[o]=n; d[o+1]=n; d[o+2]=n; d[o+3]=255;
    }
    ctx.putImageData(img,0,0);
    return c;
  }
  function makeAsphaltTexture(){
    const base = makeNoiseCanvas(512,512,66,16);
    const ctx = base.getContext('2d');
    // add subtle darker blotches
    ctx.fillStyle = 'rgba(0,0,0,0.08)';
    for(let i=0;i<120;i++){
      const x = Math.random()*512, y = Math.random()*512;
      const r = 10 + Math.random()*40;
      ctx.beginPath(); ctx.ellipse(x,y,r*1.2,r,0,0,Math.PI*2); ctx.fill();
    }
    const tex = new CanvasTexture(base);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.anisotropy = 4;
    tex.needsUpdate = true;
    return tex;
  }
  function makeRoughnessTexture(){
    const base = makeNoiseCanvas(512,512,210,30); // brighter = rougher
    const tex = new CanvasTexture(base);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.anisotropy = 4; tex.needsUpdate = true; return tex;
  }
  function makeRoadTexture({w=1024,h=512, lanes=2, dashed=true}={}){
    const c = document.createElement('canvas'); c.width=w; c.height=h;
    const ctx = c.getContext('2d');
    // base asphalt
    ctx.fillStyle = '#3e4246'; ctx.fillRect(0,0,w,h);
    // sprinkle noise
    const noise = makeNoiseCanvas(w,h,65,18);
    ctx.globalAlpha = 0.35; ctx.drawImage(noise,0,0); ctx.globalAlpha = 1;
    // edge lines
    ctx.fillStyle = '#dfe7ee';
    const edge = Math.floor(h*0.08);
    ctx.fillRect(0, edge, w, Math.max(2, Math.floor(h*0.01)));
    ctx.fillRect(0, h-edge, w, Math.max(2, Math.floor(h*0.01)));
    // center lines
    if(lanes>=2){
      const lineY = Math.floor(h/2)-2;
      ctx.fillStyle = '#e2c03b';
      if(dashed){
        const seg = 40, gap = 28;
        for(let x=0;x<w;x+=seg+gap){ ctx.fillRect(x, lineY, seg, 4); }
      } else {
        ctx.fillRect(0, lineY, w, 4);
      }
    }
    const tex = new CanvasTexture(c);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.anisotropy = 4; tex.needsUpdate = true; return tex;
  }

  // ground (flat with subtle micro undulation)
  const terrainSize = 3000; // 3km x 3km
  const segments = 200;
  const planeGeo = new PlaneGeometry(terrainSize, terrainSize, segments, segments);
  planeGeo.rotateX(-Math.PI/2);
  // slight micro variation to break perfect flatness (<= 0.15m)
  const pos = planeGeo.attributes.position;
  for(let i=0;i<pos.count;i++){
    const x = pos.getX(i), z = pos.getZ(i);
    const n = Math.sin(x*0.08) * Math.cos(z*0.06) * 0.03 + (Math.random()*2-1)*0.02;
    pos.setY(i, n*5.0); // up to ~0.15m
  }
  planeGeo.computeVertexNormals();
  function sampleGroundHeight(){ return 0; } // flat baseline for collision target

  const asphaltMap = makeAsphaltTexture(); asphaltMap.repeat.set(150,150);
  const roughMap = makeRoughnessTexture(); roughMap.repeat.set(150,150);
  const groundMat = new MeshStandardMaterial({ color:0x2a2e33, map: asphaltMap, roughnessMap: roughMap, roughness: 1.0, metalness: 0.0 });
  const ground = new Mesh(planeGeo, groundMat);
  ground.receiveShadow = true; scene.add(ground);

  // roads: two crossing planes forming an intersection
  const roadTex = makeRoadTexture({w:1024,h:512,lanes:2,dashed:true});
  roadTex.repeat.set(72,1); // scaled for long road
  const roadMat = new MeshStandardMaterial({ map: roadTex, roughness: 0.95, metalness: 0.0 });
  const roadA = new Mesh(new PlaneGeometry(2600, 14, 1, 1), roadMat);
  roadA.rotation.x = -Math.PI/2; roadA.position.y = 0.01; scene.add(roadA);
  const roadB = new Mesh(new PlaneGeometry(14, 2600, 1, 1), roadMat);
  roadB.rotation.x = -Math.PI/2; roadB.position.y = 0.011; scene.add(roadB);

  // decals: cracks and oil stains
  function makeCrackTexture(w=512,h=256, branches=18){
    const c = document.createElement('canvas'); c.width=w; c.height=h; const ctx=c.getContext('2d');
    ctx.lineCap='round'; ctx.lineJoin='round';
    for(let b=0;b<branches;b++){
      let x = Math.random()*w, y = Math.random()*h;
      let ang = Math.random()*Math.PI*2; let segs = 10 + Math.floor(Math.random()*20);
      let thick = 1 + Math.random()*2;
      ctx.beginPath(); ctx.moveTo(x,y);
      for(let s=0;s<segs;s++){
        ang += (Math.random()*2-1)*0.6; const len = 6 + Math.random()*18;
        x += Math.cos(ang)*len; y += Math.sin(ang)*len;
        ctx.lineWidth = thick * (1 - s/segs);
        ctx.strokeStyle = 'rgba(10,10,10,0.55)'; ctx.lineTo(x,y); ctx.stroke();
        // small offshoot
        if(Math.random()<0.18){
          const a2 = ang + (Math.random()*2-1)*1.2; const l2 = 4 + Math.random()*10;
          ctx.beginPath(); ctx.moveTo(x,y); ctx.lineWidth = Math.max(0.6, ctx.lineWidth*0.6);
          ctx.strokeStyle = 'rgba(10,10,10,0.45)'; ctx.lineTo(x+Math.cos(a2)*l2, y+Math.sin(a2)*l2); ctx.stroke();
        }
      }
    }
    const tex = new CanvasTexture(c); tex.needsUpdate = true; return tex;
  }
  function makeOilTexture(w=256,h=256, spots=8){
    const c = document.createElement('canvas'); c.width=w; c.height=h; const ctx=c.getContext('2d');
    for(let i=0;i<spots;i++){
      const x = Math.random()*w, y = Math.random()*h; const r = 20 + Math.random()*60;
      const g = ctx.createRadialGradient(x,y, r*0.1, x,y, r);
      g.addColorStop(0, 'rgba(20,20,20,0.6)');
      g.addColorStop(0.6, 'rgba(20,20,20,0.25)');
      g.addColorStop(1, 'rgba(20,20,20,0.0)');
      ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
      // rainbow sheen hint
      if(Math.random()<0.5){
        ctx.globalCompositeOperation='lighter';
        ctx.strokeStyle='rgba(160,120,220,0.08)'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(x,y,r*0.65,0,Math.PI*2); ctx.stroke();
        ctx.globalCompositeOperation='source-over';
      }
    }
    const tex = new CanvasTexture(c); tex.needsUpdate = true; return tex;
  }
  function addDecal(tex, x, z, w=6, h=2, rot=0, opacity=1){
    const mat = new MeshStandardMaterial({ map: tex, transparent: true, opacity, roughness: 0.95, metalness: 0.0 });
    mat.depthWrite = false; mat.polygonOffset = true; mat.polygonOffsetFactor = -1; mat.polygonOffsetUnits = -1;
    const g = new PlaneGeometry(w,h); const m = new Mesh(g, mat);
    m.rotation.x = -Math.PI/2; m.rotation.z = rot; m.position.set(x, 0.02, z); // lifted slightly to avoid z-fight
    scene.add(m); return m;
  }
  // place decals along roads
  const crackTex = makeCrackTexture();
  const oilTex = makeOilTexture();
  // along x-road (z near 0)
  for(let x=-1200; x<=1200; x+=30){
    if(Math.random()<0.85) addDecal(crackTex, x + (Math.random()*6-3), (Math.random()*6-3), 8, 2.2, Math.random()*0.6-0.3, 0.95);
    if(Math.random()<0.55) addDecal(oilTex, x + (Math.random()*6-3), (Math.random()*6-3), 3.2, 2.2, Math.random()*Math.PI, 0.85);
  }
  // along z-road (x near 0)
  for(let z=-1200; z<=1200; z+=30){
    if(Math.random()<0.85) addDecal(crackTex, (Math.random()*6-3), z + (Math.random()*6-3), 8, 2.2, Math.random()*0.6-0.3, 0.95);
    if(Math.random()<0.55) addDecal(oilTex, (Math.random()*6-3), z + (Math.random()*6-3), 3.2, 2.2, Math.random()*Math.PI, 0.85);
  }

  // puddles (glossy dark planes)
  function makePuddleTexture(w=256,h=256){
    const c = document.createElement('canvas'); c.width=w; c.height=h; const ctx=c.getContext('2d');
    const x=w/2, y=h/2, r=Math.min(w,h)*0.48;
    const g = ctx.createRadialGradient(x,y, r*0.2, x,y, r);
    g.addColorStop(0, 'rgba(30,36,44,0.8)');
    g.addColorStop(1, 'rgba(30,36,44,0.0)');
    ctx.fillStyle = g; ctx.beginPath(); ctx.ellipse(x,y, r*1.0, r*0.7, 0, 0, Math.PI*2); ctx.fill();
    return new CanvasTexture(c);
  }
  const puddleTex = makePuddleTexture();
  function addPuddle(x,z, sx=4, sz=2.6, rot=0){
    const mat = new MeshStandardMaterial({ map: puddleTex, color: 0x23262b, transparent: true, roughness: 0.12, metalness: 0.85, opacity: 0.95 });
    mat.depthWrite = false; mat.polygonOffset = true; mat.polygonOffsetFactor = -1; mat.polygonOffsetUnits = -1;
    const g = new PlaneGeometry(sx,sz); const m = new Mesh(g, mat);
    m.rotation.x = -Math.PI/2; m.rotation.z = rot; m.position.set(x, 0.021, z); scene.add(m); return m;
  }
  for(let i=0;i<60;i++){
    addPuddle((Math.random()*2-1)*1200, (Math.random()*2-1)*6, 2.5+Math.random()*4, 1.6+Math.random()*2.5, Math.random()*0.6-0.3);
    addPuddle((Math.random()*2-1)*6, (Math.random()*2-1)*1200, 2.5+Math.random()*4, 1.6+Math.random()*2.5, Math.random()*0.6-0.3);
  }

  // far building silhouettes (low-cost instanced boxes)
  const towerCount = 80;
  const towerGeo = new BoxGeometry(1,1,1);
  const towerMat = new MeshStandardMaterial({ color: 0x2a2e36, roughness: 1.0, metalness: 0.0 });
  const towerInst = new InstancedMesh(towerGeo, towerMat, towerCount);
  const tDummy = new THREE.Object3D();
  for(let i=0;i<towerCount;i++){
    const ang = Math.random()*Math.PI*2;
  const dist = 1200 + Math.random()*1200; // push deep into fog ring
    const bx = Math.cos(ang)*dist; const bz = Math.sin(ang)*dist;
    const w = 6 + Math.random()*20; const d = 6 + Math.random()*20; const h = 30 + Math.random()*180;
    tDummy.position.set(bx, h*0.5, bz);
    tDummy.scale.set(w, h, d);
    tDummy.rotation.y = Math.random()*Math.PI;
    tDummy.updateMatrix(); towerInst.setMatrixAt(i, tDummy.matrix);
  }
  towerInst.instanceMatrix.needsUpdate = true; towerInst.castShadow = false; towerInst.receiveShadow = true; scene.add(towerInst);

  // mid-rise buildings along roads (rows)
  function makeWindowTexture(w=256,h=256, gridX=8, gridY=12){
    const c = document.createElement('canvas'); c.width=w; c.height=h; const ctx=c.getContext('2d');
    ctx.fillStyle = '#2a2f35'; ctx.fillRect(0,0,w,h);
    for(let gy=0; gy<gridY; gy++){
      for(let gx=0; gx<gridX; gx++){
        const x = Math.floor((gx+0.5)*w/gridX - 8);
        const y = Math.floor((gy+0.5)*h/gridY - 6);
        const ww = 16, hh = 12;
        // some windows lit
        const lit = Math.random()<0.35;
        ctx.fillStyle = lit ? 'rgba(255,230,180,0.9)' : 'rgba(30,34,40,0.9)';
        ctx.fillRect(x,y,ww,hh);
      }
    }
    const tex = new CanvasTexture(c); tex.anisotropy=2; tex.needsUpdate=true; return tex;
  }
  const winTex = makeWindowTexture();
  const midMat = new MeshStandardMaterial({ map: winTex, color: 0x383e44, roughness: 0.95, metalness: 0.0 });
  const midGeo = new BoxGeometry(1,1,1);
  const midCount = 320;
  const midInst = new InstancedMesh(midGeo, midMat, midCount);
  scene.add(midInst);
  const midDummy = new THREE.Object3D();
  let mi = 0;
  function placeMid(x, z, w, d, h){
    midDummy.position.set(x, h*0.5, z); midDummy.scale.set(w, h, d); midDummy.rotation.y = (Math.random()*2-1)*0.08; midDummy.updateMatrix(); midInst.setMatrixAt(mi++, midDummy.matrix);
  }
  // place along four edges, staggered depth 2 rows
  const edgeX = 18, edgeZ = 18;
  for(let x=-1100; x<=1100; x+=60){
    // north/south
    placeMid(x, -(edgeZ+12), 12+Math.random()*10, 12+Math.random()*10, 20+Math.random()*70);
    if(Math.random()<0.7) placeMid(x, -(edgeZ+28), 10+Math.random()*8, 10+Math.random()*8, 18+Math.random()*60);
    placeMid(x, +(edgeZ+12), 12+Math.random()*10, 12+Math.random()*10, 20+Math.random()*70);
    if(Math.random()<0.7) placeMid(x, +(edgeZ+28), 10+Math.random()*8, 10+Math.random()*8, 18+Math.random()*60);
  }
  for(let z=-1100; z<=1100; z+=60){
    // east/west
    placeMid(-(edgeX+12), z, 12+Math.random()*10, 12+Math.random()*10, 20+Math.random()*70);
    if(Math.random()<0.7) placeMid(-(edgeX+28), z, 10+Math.random()*8, 10+Math.random()*8, 18+Math.random()*60);
    placeMid(+(edgeX+12), z, 12+Math.random()*10, 12+Math.random()*10, 20+Math.random()*70);
    if(Math.random()<0.7) placeMid(+(edgeX+28), z, 10+Math.random()*8, 10+Math.random()*8, 18+Math.random()*60);
  }
  midInst.count = mi; midInst.instanceMatrix.needsUpdate = true; midInst.castShadow = true; midInst.receiveShadow = true;

  // --- neon signs with intermittent flicker and sparks
  const neonGroup = new Group(); scene.add(neonGroup);
  const neonMeshes = []; const neonCtrl = [];
  function addNeon(x, z, w=3.2, h=1.0, color=0x66e0ff){
    const geo = new PlaneGeometry(w, h);
    const mat = new MeshStandardMaterial({ color: 0x111111, emissive: color, emissiveIntensity: 0.0, roughness: 0.9, metalness: 0.0 });
    const m = new Mesh(geo, mat); m.rotation.x = -Math.PI/2; m.rotation.z = Math.random()*Math.PI; // lay as if panel oriented randomly near ground
    // raise slightly to be visible above ground; tilt a bit
    m.position.set(x, 0.03, z); m.rotation.x = -Math.PI/2 + (Math.random()*2-1)*0.15;
    neonGroup.add(m);
    neonMeshes.push(m);
    neonCtrl.push({ base: 1.2 + Math.random()*2.0, speed: 2.0 + Math.random()*3.0, jitter: Math.random()*Math.PI*2, offProb: 0.05 + Math.random()*0.06, nextSpark: 0 });
  }
  // distribute some neons near roads
  const neonColors = [0x66e0ff, 0xff66cc, 0x6bff66, 0xfff066];
  for(let i=0;i<18;i++){
    // along x-road and z-road edges
    const onX = Math.random()<0.5;
    const col = neonColors[Math.floor(Math.random()*neonColors.length)];
    if(onX){ addNeon((Math.random()*2-1)*1100, (Math.random()<0.5? 9.0 : -9.0) + (Math.random()*2-1)*3, 3+Math.random()*2, 0.8+Math.random()*0.6, col); }
    else { addNeon((Math.random()<0.5? 9.0 : -9.0) + (Math.random()*2-1)*3, (Math.random()*2-1)*1100, 3+Math.random()*2, 0.8+Math.random()*0.6, col); }
  }

  // spark particle system (multiple ephemeral bursts)
  const sparkBursts = [];
  function spawnSparkParticles(pos){
    const count = 20;
    const g = new BufferGeometry();
    const positions = new Float32Array(count*3);
    const velocities = new Float32Array(count*3);
    for(let i=0;i<count;i++){
      const ix = i*3;
      positions[ix+0] = pos.x; positions[ix+1] = pos.y + 0.1; positions[ix+2] = pos.z;
      const a = Math.random()*Math.PI*2; const up = Math.random()*0.9 + 0.2;
      const sp = 3.0 + Math.random()*4.0;
      velocities[ix+0] = Math.cos(a)*sp*0.5; velocities[ix+1] = up*sp; velocities[ix+2] = Math.sin(a)*sp*0.5;
    }
    g.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    g.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));
    const m = new PointsMaterial({ color: 0xfff2a8, size: 0.08, transparent: true, opacity: 1.0, depthWrite:false });
    const p = new Points(g, m); p.userData.life = 0.25 + Math.random()*0.25; p.userData.age = 0;
    scene.add(p); sparkBursts.push(p);
  }

  // --- wrecked cars (low-poly)
  const carGroup = new Group(); scene.add(carGroup);
  // shared geometries/materials
  const gCarBody = new BoxGeometry(3.6, 1.2, 1.6); gCarBody.translate(0, 0.6, 0);
  const gCarCab = new BoxGeometry(2.0, 0.9, 1.5); gCarCab.translate(-0.2, 1.35, 0);
  const gWheel = new CylinderGeometry(0.36, 0.36, 0.4, 16); gWheel.rotateZ(Math.PI/2);
  const matMetal = new MeshStandardMaterial({ color: 0x4a4d50, roughness: 0.9, metalness: 0.2 });
  const matPaints = [0x5a6a77,0x7a3b3b,0x3d5a3d,0x6a5a3d,0x3a3f6a].map(c=>new MeshStandardMaterial({ color:c, roughness:0.85, metalness:0.3 }));
  const matGlass = new MeshStandardMaterial({ color: 0x88a0b5, roughness: 0.2, metalness: 0.0, transparent:true, opacity:0.5 });
  const matTire = new MeshStandardMaterial({ color: 0x1a1a1a, roughness: 1.0, metalness: 0.0 });
  function makeCar(){
    const g = new Group();
    const body = new Mesh(gCarBody, matPaints[Math.floor(Math.random()*matPaints.length)]);
    const cab = new Mesh(gCarCab, matGlass);
    const wheelPositions = [
      [ 1.3, 0.36,  0.8], [ 1.3, 0.36, -0.8],
      [-1.3, 0.36,  0.8], [-1.3, 0.36, -0.8]
    ];
    const wheels = wheelPositions.map(p=>{ const w=new Mesh(gWheel, matTire); w.position.set(p[0],p[1],p[2]); return w; });
    // damage: chance to miss a wheel or tilt
    wheels.forEach((w,idx)=>{ if(Math.random()<0.18){ w.scale.set(0.001,0.001,0.001); w.visible=false; } });
    g.add(body, cab, ...wheels);
    // slight dents by random rotations and scales
    g.rotation.y = (Math.random()*2-1)*Math.PI;
    g.rotation.z = (Math.random()*2-1)*0.06;
    g.position.y = 0.02;
    const s = 0.95 + Math.random()*0.15; g.scale.set(s,s,s);
    return g;
  }
  function spawnCarsAlongRoads(count=28){
    let c=0;
    while(c<count){
      const onX = Math.random()<0.5;
      const pos = new Vector3();
      if(onX){
        pos.x = (Math.random()*2-1)*1200; pos.z = (Math.random()<0.5? 3.6 : -3.6) + (Math.random()*2-1)*1.2;
      } else {
        pos.z = (Math.random()*2-1)*1200; pos.x = (Math.random()<0.5? 3.6 : -3.6) + (Math.random()*2-1)*1.2;
      }
      const car = makeCar(); car.position.add(pos);
      // chance to be heavily wrecked (on side)
      if(Math.random()<0.2){ car.rotation.x = (Math.random()*2-1)*0.9; car.rotation.z = (Math.random()*2-1)*0.6; }
      carGroup.add(car); c++;
    }
  }
  spawnCarsAlongRoads(30);

  // --- fallen/tilted billboards
  const signGroup = new Group(); scene.add(signGroup);
  const gPost = new CylinderGeometry(0.18,0.22,5.2,10); gPost.translate(0,2.6,0);
  const gBoard = new BoxGeometry(6.0,3.0,0.12); gBoard.translate(0,1.6,0);
  const matPost = new MeshStandardMaterial({ color:0x666a6f, roughness:0.95, metalness:0.05 });
  function makePosterTexture(w=512,h=256){
    const c = document.createElement('canvas'); c.width=w; c.height=h; const ctx = c.getContext('2d');
    ctx.fillStyle = '#2b2f36'; ctx.fillRect(0,0,w,h);
    // fake torn edges
    ctx.fillStyle = 'rgba(240,240,240,0.9)';
    ctx.fillRect(12,12,w-24,h-24);
    ctx.globalCompositeOperation='destination-out';
    for(let i=0;i<28;i++){
      const rx = 12 + Math.random()*(w-24); const ry = 12 + Math.random()*(h-24);
      ctx.beginPath(); ctx.arc(rx, ry, 6+Math.random()*22, 0, Math.PI*2); ctx.fill();
    }
    ctx.globalCompositeOperation='source-over';
    ctx.fillStyle = 'rgba(180,40,40,0.85)'; ctx.font = 'bold 56px Segoe UI'; ctx.fillText('SALE 90% OFF', 28, h/2+16);
    return new CanvasTexture(c);
  }
  const posterTex = makePosterTexture();
  const matBoard = new MeshStandardMaterial({ map: posterTex, roughness:0.9, metalness:0.0 });
  function makeBillboard(){
    const g = new Group();
    const post = new Mesh(gPost, matPost);
    const board = new Mesh(gBoard, matBoard);
    g.add(post, board);
    // random tilt or completely fallen
    if(Math.random()<0.35){
      // fallen: lay on ground
      g.rotation.x = -Math.PI/2 * (0.9 + Math.random()*0.2);
      g.position.y = 0.02;
    } else {
      g.rotation.z = (Math.random()*2-1)*0.4;
      g.position.y = 0.02;
    }
    return g;
  }
  function spawnBillboards(n=12){
    for(let i=0;i<n;i++){
      const onX = Math.random()<0.5; const b = makeBillboard();
      if(onX){ b.position.x = (Math.random()*2-1)*1100; b.position.z = (Math.random()<0.5? 10.5 : -10.5) + (Math.random()*2-1)*4; }
      else { b.position.z = (Math.random()*2-1)*1100; b.position.x = (Math.random()<0.5? 10.5 : -10.5) + (Math.random()*2-1)*4; }
      b.rotation.y = Math.random()*Math.PI;
      signGroup.add(b);
    }
  }
  spawnBillboards(14);

  // --- guardrails along road edges (posts + rails)
  const guardPostGeo = new CylinderGeometry(0.08, 0.08, 1.1, 12);
  guardPostGeo.translate(0, 0.55, 0);
  const guardRailGeo = new BoxGeometry(3.0, 0.14, 0.15);
  guardRailGeo.translate(0, 0.95, 0); // rail height above ground
  const guardMat = new MeshStandardMaterial({ color: 0xaab0b6, roughness: 0.85, metalness: 0.15 });
  // layout along long roads: offset from road edges by ~2.5m
  const railSpan = 3.0; // horizontal span per rail segment
  const sectionLen = 1200; // half-length along each road
  // compute counts
  const railCountPerSide = Math.floor((sectionLen*2) / railSpan);
  const postSpacing = 3.0;
  const postCountPerSide = Math.floor((sectionLen*2) / postSpacing) + 1;
  const sides = [ // [axis, fixedCoord, offsetOutward]
    { axis:'x', z:  10.0 },
    { axis:'x', z: -10.0 },
    { axis:'z', x:  10.0 },
    { axis:'z', x: -10.0 },
  ];
  const totalPosts = postCountPerSide * sides.length;
  const totalRails = railCountPerSide * sides.length;
  const postInst = new InstancedMesh(guardPostGeo, guardMat, totalPosts);
  const railInst = new InstancedMesh(guardRailGeo, guardMat, totalRails);
  postInst.castShadow = true; postInst.receiveShadow = true;
  railInst.castShadow = true; railInst.receiveShadow = true;
  scene.add(postInst); scene.add(railInst);
  const tmp = new THREE.Object3D();
  let pi = 0, ri = 0;
  sides.forEach(side=>{
    // posts
    for(let i=0;i<postCountPerSide;i++){
      const t = -sectionLen + i*postSpacing;
      const broken = Math.random()<0.07; // missing post
      tmp.rotation.set(0,0,0);
      if(side.axis==='x'){
        tmp.position.set(t, 0.02, side.z);
        tmp.rotation.y = (Math.random()*2-1)*0.06;
      } else {
        tmp.position.set(side.x, 0.02, t);
        tmp.rotation.y = (Math.random()*2-1)*0.06;
      }
      // tilt variation
      tmp.rotation.z = (Math.random()*2-1)*0.06;
      tmp.updateMatrix();
      if(!broken){ postInst.setMatrixAt(pi++, tmp.matrix); }
    }
    // rails
    for(let i=0;i<railCountPerSide;i++){
      const t = -sectionLen + i*railSpan + railSpan*0.5;
      const broken = Math.random()<0.12; // missing rail
      tmp.rotation.set(0,0,0);
      if(side.axis==='x'){
        tmp.position.set(t, 0.02, side.z);
        tmp.rotation.y = 0;
      } else {
        tmp.position.set(side.x, 0.02, t);
        tmp.rotation.y = Math.PI/2;
      }
      // slight vertical variance to look bent
      tmp.position.y += (Math.random()*2-1)*0.04;
      // occasional heavy bend
      if(Math.random()<0.08){ tmp.rotation.z = (Math.random()*2-1)*0.25; }
      tmp.updateMatrix();
      if(!broken){ railInst.setMatrixAt(ri++, tmp.matrix); }
    }
  });
  postInst.count = pi; postInst.instanceMatrix.needsUpdate = true;
  railInst.count = ri; railInst.instanceMatrix.needsUpdate = true;

  // --- traffic cones (body + base instanced)
  const coneCount = 120;
  const coneBodyGeo = new ConeGeometry(0.32, 0.7, 24);
  coneBodyGeo.translate(0, 0.35, 0);
  const coneBaseGeo = new CylinderGeometry(0.36, 0.36, 0.06, 20);
  coneBaseGeo.translate(0, 0.03, 0);
  const coneMat = new MeshStandardMaterial({ color: 0xd96a1a, roughness: 0.9, metalness: 0.05 });
  const coneBaseMat = new MeshStandardMaterial({ color: 0x333333, roughness: 1.0, metalness: 0.0 });
  const coneInst = new InstancedMesh(coneBodyGeo, coneMat, coneCount);
  const coneBaseInst = new InstancedMesh(coneBaseGeo, coneBaseMat, coneCount);
  coneInst.castShadow = true; coneInst.receiveShadow = true; coneBaseInst.castShadow = true; coneBaseInst.receiveShadow = true;
  scene.add(coneInst); scene.add(coneBaseInst);
  let ci = 0; const cDummy = new THREE.Object3D();
  function placeCone(x,z){
    cDummy.position.set(x, 0.02, z);
    cDummy.rotation.y = Math.random()*Math.PI*2;
    cDummy.rotation.z = (Math.random()*2-1)*0.12;
    const s = 0.9 + Math.random()*0.25; cDummy.scale.set(s,s,s);
    cDummy.updateMatrix();
    coneInst.setMatrixAt(ci, cDummy.matrix);
    coneBaseInst.setMatrixAt(ci, cDummy.matrix);
    ci++;
  }
  // scatter cones near intersection and random road segments
  for(let i=0;i<40;i++){
    placeCone((Math.random()*2-1)*12, (Math.random()*2-1)*12);
  }
  for(let i=0;i<40;i++){
    placeCone((Math.random()*2-1)*1200, (Math.random()<0.5? 6.5 : -6.5) + (Math.random()*2-1)*3);
  }
  for(let i=0;i<40;i++){
    placeCone((Math.random()<0.5? 6.5 : -6.5) + (Math.random()*2-1)*3, (Math.random()*2-1)*1200);
  }
  coneInst.count = ci; coneBaseInst.count = ci;
  coneInst.instanceMatrix.needsUpdate = true; coneBaseInst.instanceMatrix.needsUpdate = true;

  // streetlights (poles instanced + point lights + small emissive heads)
  const lampPositions = [];
  // along roadA (x-axis road), place rows at z=±7
  for(let x=-1300; x<=1300; x+=50){ lampPositions.push(new Vector3(x,0,7)); lampPositions.push(new Vector3(x,0,-7)); }
  // along roadB (z-axis road), place rows at x=±7
  for(let z=-1300; z<=1300; z+=50){ lampPositions.push(new Vector3(7,0,z)); lampPositions.push(new Vector3(-7,0,z)); }
  const poleGeo = new CylinderGeometry(0.08, 0.1, 5.2, 10);
  poleGeo.translate(0, 2.6, 0);
  const poleMat = new MeshStandardMaterial({ color: 0x6b6f75, roughness: 0.9, metalness: 0.05 });
  const poleInst = new InstancedMesh(poleGeo, poleMat, lampPositions.length);
  poleInst.castShadow = false; poleInst.receiveShadow = true; scene.add(poleInst);
  const lampLights = []; const lampMeshes = []; const lampFlick = [];
  const lampHeadGeo = new BoxGeometry(0.36,0.18,0.36);
  const lampHeadMat = new MeshStandardMaterial({ color: 0x111111, emissive: 0x99bbff, emissiveIntensity: 1.0, roughness: 0.6, metalness: 0.0 });
  const dummyObj = new THREE.Object3D();
  lampPositions.forEach((p, i)=>{
    // offset from ground (y from flat base)
    const baseY = 0; // ground baseline
    dummyObj.position.set(p.x, baseY, p.z);
    // small lateral offset outward from road center
    if (Math.abs(p.z) > 0) dummyObj.position.z += (p.z>0? 1.0 : -1.0);
    if (Math.abs(p.x) > 0 && Math.abs(p.z) < 0.001) dummyObj.position.x += (p.x>0? 1.0 : -1.0);
    dummyObj.rotation.set(0, 0, 0);
    dummyObj.updateMatrix();
    poleInst.setMatrixAt(i, dummyObj.matrix);
    // lamp head mesh
    const head = new Mesh(lampHeadGeo, lampHeadMat.clone());
    head.position.set(dummyObj.position.x, baseY + 5.1, dummyObj.position.z);
    head.castShadow = false; head.receiveShadow = false; scene.add(head); lampMeshes.push(head);
    // point light for emission
  const warm = new PointLight(0x99bbff, 3.0, 16, 2.0);
    warm.position.set(head.position.x, head.position.y - 0.05, head.position.z);
  // disable shadows to avoid exceeding sampler limits with many lights
  warm.castShadow = false; scene.add(warm); lampLights.push(warm);
    // flicker parameters
    lampFlick.push({ base: 3.2, speed: 2.0 + Math.random()*1.5, jitter: Math.random()*Math.PI*2, offProb: 0.08 + Math.random()*0.08 });
  });
  poleInst.instanceMatrix.needsUpdate = true;

  // utility poles with intermittent arcing light
  const poleGroup = new THREE.Group(); scene.add(poleGroup);
  const utilPoles = []; // {mesh, head, light, ctrl}
  (function spawnUtilityPoles(){
    const poleGeo = new CylinderGeometry(0.16, 0.2, 7.0, 12); poleGeo.translate(0, 3.5, 0);
    const poleMat = new MeshStandardMaterial({ color: 0x5e5b58, roughness: 0.95, metalness: 0.05 });
    const headGeo = new BoxGeometry(0.28,0.22,0.28);
    const headMat = new MeshStandardMaterial({ color: 0x222222, emissive: 0x99ccff, emissiveIntensity: 0.0, roughness:0.7, metalness:0.0 });
    // positions along roads every ~300m
    const positions = [];
    for(let x=-1200; x<=1200; x+=300){ positions.push(new Vector3(x,0, 11.8)); positions.push(new Vector3(x,0, -11.8)); }
    for(let z=-1200; z<=1200; z+=300){ positions.push(new Vector3(11.8,0, z)); positions.push(new Vector3(-11.8,0, z)); }
    positions.forEach(p=>{
      const m = new Mesh(poleGeo, poleMat);
      m.position.set(p.x, 0.02, p.z);
      m.rotation.y = (Math.random()*2-1)*0.2; m.rotation.z = (Math.random()*2-1)*0.05;
      poleGroup.add(m);
      const head = new Mesh(headGeo, headMat.clone());
      head.position.set(p.x + (Math.random()*2-1)*0.15, 6.8 + (Math.random()*2-1)*0.1, p.z + (Math.random()*2-1)*0.15);
      scene.add(head);
      const arc = new PointLight(0xa9d6ff, 0.0, 16, 2.2); arc.position.copy(head.position); arc.castShadow = false; scene.add(arc);
      const ctrl = { base: 1.4 + Math.random()*1.6, speed: 3.0 + Math.random()*3.0, jitter: Math.random()*Math.PI*2, offProb: 0.1 + Math.random()*0.08, nextSpark: 0 };
      utilPoles.push({ mesh:m, head, light:arc, ctrl });
    });
  })();

  // simple concrete barricades (instanced boxes) near the intersection corners
  const barricadePositions = [];
  function addBarricadeCluster(cx, cz, count=12, spread=6){
    for(let i=0;i<count;i++){
      const ox = (Math.random()*2-1)*spread;
      const oz = (Math.random()*2-1)*spread;
      barricadePositions.push(new Vector3(cx+ox, 0, cz+oz));
    }
  }
  addBarricadeCluster(16, 16); addBarricadeCluster(-16, 16); addBarricadeCluster(16, -16); addBarricadeCluster(-16, -16);
  const barGeo = new BoxGeometry(1.6,0.9,0.6);
  const barMat = new MeshStandardMaterial({ color: 0x8b8f95, roughness: 0.95, metalness: 0.0 });
  const barInst = new InstancedMesh(barGeo, barMat, barricadePositions.length);
  const barDummy = new THREE.Object3D();
  barricadePositions.forEach((p, i)=>{
    barDummy.position.set(p.x, 0.45, p.z);
    barDummy.rotation.y = (Math.random()*2-1)*0.7;
    barDummy.rotation.z = (Math.random()*2-1)*0.12;
    const s = 0.9 + Math.random()*0.2; barDummy.scale.set(s, s, s);
    barDummy.updateMatrix(); barInst.setMatrixAt(i, barDummy.matrix);
  });
  barInst.castShadow = true; barInst.receiveShadow = true; scene.add(barInst);

  // subtle dust particles (points)
  const dustGeo = new BufferGeometry();
  const dustCount = 800;
  const posArr = new Float32Array(dustCount*3);
  const baseXZ = 200, baseY = 0.6;
  for(let i=0;i<dustCount;i++){
    posArr[i*3+0] = (Math.random()*2-1)*baseXZ;
    posArr[i*3+1] = baseY + Math.random()*2.5;
    posArr[i*3+2] = (Math.random()*2-1)*baseXZ;
  }
  dustGeo.setAttribute('position', new THREE.Float32BufferAttribute(posArr, 3));
  const dustMat = new PointsMaterial({ color: 0xb7bdc3, size: 0.18, sizeAttenuation: true, transparent: true, opacity: 0.25, depthWrite: false });
  const dustPoints = new Points(dustGeo, dustMat); scene.add(dustPoints);

  // --- enemies: glowing mist humanoids (2m tall)
  const enemyGroup = new Group(); scene.add(enemyGroup);
  const enemies = [];
  function makeMistMaterial(){
    const noiseTex = (function(){
      const c = document.createElement('canvas'); c.width=256; c.height=256; const ctx=c.getContext('2d');
      const img = ctx.createImageData(256,256); const d=img.data;
      for(let i=0;i<256*256;i++){
        const n = Math.floor(80 + Math.random()*160);
        const o=i*4; d[o]=n; d[o+1]=n; d[o+2]=n; d[o+3]=255;
      }
      ctx.putImageData(img,0,0); const t=new CanvasTexture(c); t.wrapS=t.wrapT=THREE.RepeatWrapping; t.needsUpdate=true; return t;
    })();
    return new ShaderMaterial({
      uniforms:{ time:{value:0}, tex:{value:noiseTex}, color:{value:new Color(0xbfd8ff)}, emissive:{value:0.6} },
      transparent:true, depthWrite:false, side:DoubleSide,
      vertexShader:`
        uniform float time; varying vec2 vUv; varying float vFade; 
        void main(){ vUv=uv; 
          vec3 pos = position; // subtle wobble
          float w = (sin(time*1.2 + position.y*3.0 + position.x*2.1)+sin(time*0.7+position.y*4.3))*0.02; 
          pos.x += w; pos.z += w*0.6; 
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos,1.0);
          vFade = position.y; // fade to feet
        }`,
      fragmentShader:`
        uniform sampler2D tex; uniform vec3 color; uniform float emissive; varying vec2 vUv; varying float vFade; 
        void main(){
          vec2 uv = vUv; uv.y *= 2.0; // stretch noise vertically
          float n = texture2D(tex, uv).r; 
          float alpha = smoothstep(0.35, 0.8, n) * smoothstep(1.2, 0.1, vFade); // tapered bottom
          alpha *= 0.85; if(alpha < 0.02) discard;
          vec3 col = color * (0.6 + n*0.7);
          gl_FragColor = vec4(col, alpha);
          // soft additive-ish glow
          gl_FragColor.rgb += col * emissive * alpha * 0.4;
        }`
    });
  }
  const mistMat = makeMistMaterial();
  function createMistEnemy(x,z){
    // crossed planes (billboard-like), height ~2.0m
    const w=0.9, h=2.0;
    const geo = new PlaneGeometry(w,h); geo.translate(0,h/2,0);
    const a = new Mesh(geo, mistMat); const b = new Mesh(geo, mistMat);
    b.rotation.y = Math.PI/2;
    const g = new Group(); g.add(a,b);
    g.position.set(x, 0.02, z);
    enemyGroup.add(g);
    return { node:g, t:Math.random()*1000, speed: 0.6+Math.random()*0.6, dir: Math.random()*Math.PI*2, sway: Math.random()*Math.PI*2 };
  }
  function spawnEnemies(n=6){
    for(let i=0;i<n;i++){
      const ang = Math.random()*Math.PI*2; const dist = 40 + Math.random()*80;
      const ex = camera.position.x + Math.cos(ang)*dist;
      const ez = camera.position.z + Math.sin(ang)*dist;
      enemies.push(createMistEnemy(ex, ez));
    }
  }
  spawnEnemies(7);

  // night sky: stars
  (function addStars(){
    const starN = 1200; const g = new BufferGeometry();
    const arr = new Float32Array(starN*3);
    for(let i=0;i<starN;i++){
      const r = 1800 + Math.random()*1200;
      const ang = Math.random()*Math.PI*2;
      const h = 600 + Math.random()*800;
      arr[i*3+0] = Math.cos(ang)*r;
      arr[i*3+1] = h;
      arr[i*3+2] = Math.sin(ang)*r;
    }
    g.setAttribute('position', new THREE.Float32BufferAttribute(arr,3));
    const m = new PointsMaterial({ color:0xcfd8ff, size:0.9, sizeAttenuation:true, transparent:true, opacity:0.85, depthWrite:false });
    const stars = new Points(g,m); scene.add(stars);
  })();

  // moon: billboarded plane with procedural texture
  function makeMoonTexture(w=256,h=256){
    const c=document.createElement('canvas'); c.width=w; c.height=h; const ctx=c.getContext('2d');
    ctx.fillStyle='#000'; ctx.fillRect(0,0,w,h);
    const cx=w/2, cy=h/2, r=Math.min(w,h)*0.46;
    // base disk
    ctx.fillStyle='#dfe8ff'; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();
    // simple craters
    for(let i=0;i<26;i++){
      const a=Math.random()*Math.PI*2; const rr=r*(0.2+Math.random()*0.7); const d=0.08*r+Math.random()*0.16*r;
      const x=cx+Math.cos(a)*rr; const y=cy+Math.sin(a)*rr;
      const grd=ctx.createRadialGradient(x,y, d*0.2, x,y, d);
      grd.addColorStop(0,'rgba(120,130,160,0.35)');
      grd.addColorStop(1,'rgba(0,0,0,0)');
      ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(x,y,d,0,Math.PI*2); ctx.fill();
    }
    return new CanvasTexture(c);
  }
  const moonTex = makeMoonTexture();
  const moonMat = new MeshBasicMaterial({ map: moonTex, transparent:true, depthWrite:false, side:DoubleSide, color:0xffffff });
  const moonGeo = new PlaneGeometry(80,80);
  const moon = new Mesh(moonGeo, moonMat);
  moon.position.set(-600, 420, -800);
  scene.add(moon);

  // --- simple collision system with 10m chunking (XZ plane)
  const playerRadius = 0.45; // approximate camera capsule radius on ground plane
  const CHUNK_SIZE = 10; // 10 meters per chunk
  const circleColliders = []; // flat list (debug/optional)
  const segmentColliders = []; // flat list (debug/optional)
  const circleChunks = new Map(); // key:"cx,cz" -> Array<{x,z,r}>
  const segmentChunks = new Map(); // key:"cx,cz" -> Array<segment>
  const _tmpV = new THREE.Vector3();
  function toChunkCoord(v){ return Math.floor(v / CHUNK_SIZE); }
  function chunkKey(cx, cz){ return cx+','+cz; }
  function pushCircleToChunk(obj){
    const cx = toChunkCoord(obj.x), cz = toChunkCoord(obj.z);
    const key = chunkKey(cx, cz);
    let arr = circleChunks.get(key); if(!arr){ arr = []; circleChunks.set(key, arr); }
    arr.push(obj);
  }
  function pushSegmentToChunks(seg){
    const minX = Math.min(seg.ax, seg.bx) - seg.r, maxX = Math.max(seg.ax, seg.bx) + seg.r;
    const minZ = Math.min(seg.az, seg.bz) - seg.r, maxZ = Math.max(seg.az, seg.bz) + seg.r;
    const cminX = toChunkCoord(minX), cmaxX = toChunkCoord(maxX);
    const cminZ = toChunkCoord(minZ), cmaxZ = toChunkCoord(maxZ);
    for(let cz=cminZ; cz<=cmaxZ; cz++){
      for(let cx=cminX; cx<=cmaxX; cx++){
        const key = chunkKey(cx, cz);
        let arr = segmentChunks.get(key); if(!arr){ arr = []; segmentChunks.set(key, arr); }
        arr.push(seg);
      }
    }
  }
  function addCollider(x, z, r){
    const obj = { x, z, r };
    circleColliders.push(obj);
    pushCircleToChunk(obj);
  }
  function collectNearby(posX, posZ, extraRadius=3){
  const cx = toChunkCoord(posX), cz = toChunkCoord(posZ);
  // LOAD CHUNK RADIUS is fixed to 4 as requested (pre-collected here via chunk maps)
  const range = 4; // fixed load radius
    const circles = [];
    const segments = [];
    for(let dz=-range; dz<=range; dz++){
      for(let dx=-range; dx<=range; dx++){
        const key = chunkKey(cx+dx, cz+dz);
        const ca = circleChunks.get(key); if(ca) circles.push(...ca);
        const sa = segmentChunks.get(key); if(sa) segments.push(...sa);
      }
    }
    return { circles, segments };
  }
  function rebuildColliders(){
    circleColliders.length = 0; segmentColliders.length = 0;
    circleChunks.clear(); segmentChunks.clear();
    // street lamp poles (from instanced matrices if available)
    if(typeof poleInst !== 'undefined' && poleInst && typeof poleInst.count === 'number'){
      const m = new THREE.Matrix4(); const pos = new THREE.Vector3(); const quat = new THREE.Quaternion(); const scl = new THREE.Vector3();
      const n = poleInst.count;
      for(let i=0;i<n;i++){
        poleInst.getMatrixAt(i, m); m.decompose(pos, quat, scl);
        addCollider(pos.x, pos.z, 0.45);
      }
    } else if(Array.isArray(lampPositions)){
      // fallback
      for(const p of lampPositions){ addCollider(p.x, p.z, 0.45); }
    }
    // utility poles (individual meshes in utilPoles)
    if(Array.isArray(utilPoles)){
      for(const up of utilPoles){ if(up && up.mesh && up.mesh.position){ addCollider(up.mesh.position.x, up.mesh.position.z, 0.5); } }
    }
    // barricades (from instanced matrices if available)
    if(typeof barInst !== 'undefined' && barInst && typeof barInst.count === 'number'){
      const m = new THREE.Matrix4(); const pos = new THREE.Vector3(); const quat = new THREE.Quaternion(); const scl = new THREE.Vector3();
      const n = barInst.count;
      for(let i=0;i<n;i++){
        barInst.getMatrixAt(i, m); m.decompose(pos, quat, scl);
        // approximate as circle using half-width/depth
        const r = 0.5 * Math.hypot(0.8*scl.x, 0.3*scl.z); // tuned
        addCollider(pos.x, pos.z, Math.max(0.5, r));
      }
    } else if(Array.isArray(barricadePositions)){
      for(const bp of barricadePositions){ addCollider(bp.x, bp.z, 0.9); }
    }
    // cars (rough sphere around car body)
    if(carGroup && carGroup.children){
      for(const c of carGroup.children){ addCollider(c.position.x, c.position.z, 2.0); }
    }
    // signs / billboards
    if(signGroup && signGroup.children){
      for(const s of signGroup.children){ addCollider(s.position.x, s.position.z, 2.2); }
    }
    // neon panels
    if(Array.isArray(neonMeshes)){
      for(const n of neonMeshes){ addCollider(n.position.x, n.position.z, 1.0); }
    }
    // guardrail posts (instanced)
    if(typeof postInst !== 'undefined' && postInst && typeof postInst.count === 'number'){
      const m = new THREE.Matrix4(); const pos = new THREE.Vector3(); const quat = new THREE.Quaternion(); const scl = new THREE.Vector3();
      const n = postInst.count;
      for(let i=0;i<n;i++){
        postInst.getMatrixAt(i, m); m.decompose(pos, quat, scl);
        addCollider(pos.x, pos.z, 0.2);
      }
    }
    // guardrail rails (as segment capsules)
    if(typeof railInst !== 'undefined' && railInst && typeof railInst.count === 'number'){
      const m = new THREE.Matrix4(); const pos = new THREE.Vector3(); const quat = new THREE.Quaternion(); const scl = new THREE.Vector3();
      const n = railInst.count; const localA = new THREE.Vector3(-1.5,0,0); const localB = new THREE.Vector3(1.5,0,0);
      const ta = new THREE.Vector3(); const tb = new THREE.Vector3();
      for(let i=0;i<n;i++){
        railInst.getMatrixAt(i, m); m.decompose(pos, quat, scl);
        ta.copy(localA).applyQuaternion(quat).add(pos);
        tb.copy(localB).applyQuaternion(quat).add(pos);
        const cx = (ta.x + tb.x) * 0.5; const cz = (ta.z + tb.z) * 0.5;
        const hx = Math.abs(tb.x - ta.x) * 0.5; const hz = Math.abs(tb.z - ta.z) * 0.5;
        const seg = { ax:ta.x, az:ta.z, bx:tb.x, bz:tb.z, cx, cz, hx, hz, r: 0.18 };
        segmentColliders.push(seg);
        pushSegmentToChunks(seg);
      }
    }
    // traffic cones (use base instanced positions)
    if(typeof coneBaseInst !== 'undefined' && coneBaseInst && typeof coneBaseInst.count === 'number'){
      const m = new THREE.Matrix4(); const pos = new THREE.Vector3(); const quat = new THREE.Quaternion(); const scl = new THREE.Vector3();
      const n = coneBaseInst.count;
      for(let i=0;i<n;i++){
        coneBaseInst.getMatrixAt(i, m); m.decompose(pos, quat, scl);
        addCollider(pos.x, pos.z, 0.35 * Math.max(scl.x, scl.z));
      }
    }
    // mid-rise buildings (instanced)
    if(typeof midInst !== 'undefined' && midInst && typeof midInst.count === 'number'){
      const m = new THREE.Matrix4(); const pos = new THREE.Vector3(); const quat = new THREE.Quaternion(); const scl = new THREE.Vector3();
      const n = midInst.count;
      for(let i=0;i<n;i++){
        midInst.getMatrixAt(i, m); m.decompose(pos, quat, scl);
        const r = 0.5 * Math.hypot(scl.x, scl.z);
        addCollider(pos.x, pos.z, Math.max(2.5, r));
      }
    }
    // far towers (instanced)
    if(typeof towerInst !== 'undefined' && towerInst && typeof towerInst.count === 'number'){
      const m = new THREE.Matrix4(); const pos = new THREE.Vector3(); const quat = new THREE.Quaternion(); const scl = new THREE.Vector3();
      const n = towerInst.count;
      for(let i=0;i<n;i++){
        towerInst.getMatrixAt(i, m); m.decompose(pos, quat, scl);
        const r = 0.5 * Math.hypot(scl.x, scl.z);
        addCollider(pos.x, pos.z, Math.max(2.0, r));
      }
    }
  }
  rebuildColliders();
  function resolveCollisionsXZ(pos, radius){
    const { circles, segments } = collectNearby(pos.x, pos.z, 4);
    // circle colliders
    for(let i=0;i<circles.length;i++){
      const c = circles[i];
      const dx = pos.x - c.x; const dz = pos.z - c.z;
      const rr = radius + c.r;
      // quick AABB-like reject to reduce sqrt calls
      const aabbR = rr + 0.2; if(Math.abs(dx) > aabbR || Math.abs(dz) > aabbR) continue;
      const distSq = dx*dx + dz*dz;
      if(distSq < rr*rr){
        const dist = Math.sqrt(Math.max(1e-6, distSq));
        // if exactly overlapping center, nudge in a stable arbitrary direction
        const nx = dist > 1e-6 ? dx/dist : 1.0; const nz = dist > 1e-6 ? dz/dist : 0.0;
        const penetration = rr - dist;
        pos.x += nx * penetration; pos.z += nz * penetration;
      }
    }
    // segment capsule colliders (guardrails)
    for(let i=0;i<segments.length;i++){
      const s = segments[i];
      // coarse reject using segment AABB expanded by radius
      const pad = radius + s.r + 0.2;
      if(Math.abs(pos.x - s.cx) > s.hx + pad || Math.abs(pos.z - s.cz) > s.hz + pad) continue;
      const vx = s.bx - s.ax; const vz = s.bz - s.az;
      const len2 = vx*vx + vz*vz; if(len2 < 1e-6) continue;
      const wx = pos.x - s.ax; const wz = pos.z - s.az;
      let t = (wx*vx + wz*vz) / len2; if(t < 0) t = 0; else if(t > 1) t = 1;
      const cx = s.ax + t*vx; const cz = s.az + t*vz;
      let px = pos.x - cx; let pz = pos.z - cz;
      const rr = radius + s.r;
      const d2 = px*px + pz*pz;
      if(d2 < rr*rr){
        const d = Math.sqrt(Math.max(d2, 1e-8));
        let nx, nz;
        if(d > 1e-8){ nx = px/d; nz = pz/d; }
        else { // exactly on center: use perpendicular to segment as fallback
          const segLen = Math.sqrt(len2) || 1.0; nx = +vz/segLen; nz = -vx/segLen;
        }
        const penetration = rr - d;
        pos.x += nx * penetration; pos.z += nz * penetration;
      }
    }
    return pos;
  }

  // player movement (pointer lock FPS)
  let pitch = 0, yaw = 0;
  const velocity = new Vector3(0,0,0);
  const move = { forward:false, back:false, left:false, right:false };
  const speed = 8.0;
  const hVel = new Vector3(0,0,0);
  const accel = 40.0, deccel = 30.0;
  let velocityY = 0; const gravity = -25.0; const jumpSpeed = 10.0; let grounded = false;
  let dashTime = 0; const dashDuration = 0.18; let dashCooldown = 0; const dashCooldownDur = 0.8; const dashMultiplier = 1.0; // 新ダッシュ=旧歩行
  let stamina = 100.0; const staminaMax = 100.0; const staminaUseRate = 6.0; const staminaRegenRate = 18.0; let health = 100.0; const healthMax=100.0; let dashHeld=false;
  // スタミナ枯渇時の鈍足・ダッシュ不可状態
  let exhausted = false; const slowMultiplier = 0.5;

  function onMouseMove(e){
    if(document.pointerLockElement !== document.body) return;
    const movementX = e.movementX || 0; const movementY = e.movementY || 0;
    yaw -= movementX * 0.002; pitch -= movementY * 0.002;
    pitch = Math.max(-Math.PI/2+0.01, Math.min(Math.PI/2-0.01, pitch));
    camera.quaternion.setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));
  }
  function onKey(e, down){
    const k = e.key.toLowerCase();
  if(k==='w') move.forward = down; if(k==='s') move.back = down; if(k==='a') move.left = down; if(k==='d') move.right = down;
  if(k==='m' && down){ toggleMap(); if(mapVisible) drawMap(); }
  if(k==='o' && down){ toggleSettings(); }
    // Shift の押下/解放を常に反映（keyupでも反映されるように）
    if(e.code === 'ShiftLeft' || e.code === 'ShiftRight' || e.key === 'Shift'){
      dashHeld = down;
      // ダッシュの瞬間ブーストは keydown のみで発火（疲労状態は不可）
      if(down && !exhausted && dashCooldown<=0 && dashTime<=0 && stamina>5){ dashTime=dashDuration; dashCooldown=dashCooldownDur; }
    }
    if(down){
      if(e.code === 'Space' || k===' ' || k==='spacebar'){ if(grounded){ velocityY = jumpSpeed; grounded=false; } }
    }
  }
  window.addEventListener('mousemove', onMouseMove);
  window.addEventListener('keydown', (e)=>onKey(e,true));
  window.addEventListener('keyup', (e)=>onKey(e,false));
  window.addEventListener('resize', sizeMapCanvas);
  // 安全策: フォーカス喪失や可視状態変化、PointerLock解除時にダッシュ状態を解除
  window.addEventListener('blur', ()=>{ dashHeld = false; });
  document.addEventListener('visibilitychange', ()=>{ if(document.hidden){ dashHeld = false; } });
  document.addEventListener('pointerlockchange', ()=>{ if(document.pointerLockElement !== document.body){ dashHeld = false; } });

  // full map overlay (toggle with 'm')
  let mapVisible = false;
  const mapOverlay = document.createElement('div');
  mapOverlay.id = 'map-overlay';
  Object.assign(mapOverlay.style, { position:'fixed', left:'0', top:'0', width:'100%', height:'100%', display:'none', background:'rgba(0,0,0,0.65)', zIndex:'9999', alignItems:'center', justifyContent:'center' });
  mapOverlay.style.display = 'none';
  mapOverlay.style.pointerEvents = 'none';
  const mapCanvas = document.createElement('canvas');
  const mapCtx = mapCanvas.getContext('2d');
  mapOverlay.appendChild(mapCanvas);
  document.body.appendChild(mapOverlay);
  function sizeMapCanvas(){
    const s = Math.min(window.innerWidth, window.innerHeight) * 0.9;
    mapCanvas.width = Math.max(400, Math.floor(s));
    mapCanvas.height = mapCanvas.width; // square
    mapCanvas.style.boxShadow = '0 0 24px rgba(0,0,0,0.6)';
    mapCanvas.style.border = '2px solid rgba(255,255,255,0.2)';
  }
  sizeMapCanvas();
  // settings overlay (toggle with 'o')
  let settingsVisible = false;
  const settingsOverlay = document.createElement('div');
  settingsOverlay.id = 'settings-overlay';
  Object.assign(settingsOverlay.style, { position:'fixed', left:'0', top:'0', width:'100%', height:'100%', display:'none', background:'rgba(0,0,0,0.6)', zIndex:'9999', alignItems:'center', justifyContent:'center' });
  const settingsPanel = document.createElement('div');
  Object.assign(settingsPanel.style, { background:'rgba(20,22,26,0.95)', color:'#fff', padding:'16px 18px', borderRadius:'8px', minWidth:'320px', boxShadow:'0 8px 24px rgba(0,0,0,0.5)' });
  settingsPanel.innerHTML = `
    <div style="font-size:18px;font-weight:700;margin-bottom:12px">設定</div>
    <div style="margin:10px 0">
      <label for="draw-range">描画範囲（チャンク半径）: <span id="draw-value"></span></label>
      <input id="draw-range" type="range" min="4" max="12" step="1" value="8" style="width:100%" />
    </div>
    <div style="margin:10px 0;color:#cfd8ff">読み込み範囲は 4 チャンクで固定</div>
    <div style="margin-top:12px;text-align:right"><button id="close-settings" style="padding:6px 10px;border-radius:6px;border:0;background:#445; color:#fff">閉じる (O)</button></div>
  `;
  settingsOverlay.appendChild(settingsPanel);
  document.body.appendChild(settingsOverlay);
  function toggleSettings(force){
    if(typeof force==='boolean') settingsVisible = force; else settingsVisible = !settingsVisible;
    settingsOverlay.style.display = settingsVisible ? 'flex' : 'none';
  }
  function toggleMap(force){
    if(typeof force==='boolean') mapVisible = force; else mapVisible = !mapVisible;
    mapOverlay.style.display = mapVisible ? 'flex' : 'none';
  }
  // draw distance (chunks)
  let drawChunkRadius = parseInt(localStorage.getItem('drawChunks')||'8',10);
  drawChunkRadius = Math.max(4, Math.min(12, isNaN(drawChunkRadius)?8:drawChunkRadius));
  const drawInput = settingsPanel.querySelector('#draw-range');
  const drawValue = settingsPanel.querySelector('#draw-value');
  const closeBtn = settingsPanel.querySelector('#close-settings');
  if(drawInput && drawValue){
    drawInput.value = String(drawChunkRadius);
    drawValue.textContent = `${drawChunkRadius} チャンク`;
    drawInput.addEventListener('input', ()=>{
      drawChunkRadius = Math.max(4, Math.min(12, parseInt(drawInput.value,10)||8));
      drawValue.textContent = `${drawChunkRadius} チャンク`;
      localStorage.setItem('drawChunks', String(drawChunkRadius));
    });
  }
  if(closeBtn){ closeBtn.addEventListener('click', ()=> toggleSettings(false)); }
  // helper: world->map
  const halfSize = terrainSize/2;
  function w2mX(x, size){ return (x + halfSize) / terrainSize * size; }
  function w2mZ(z, size){ return (z + halfSize) / terrainSize * size; }
  function drawMap(){
    const W = mapCanvas.width, H = mapCanvas.height; const size = W;
    // background grid
    mapCtx.clearRect(0,0,W,H);
    mapCtx.fillStyle = '#131518'; mapCtx.fillRect(0,0,W,H);
    // grid lines
    mapCtx.strokeStyle = 'rgba(255,255,255,0.06)'; mapCtx.lineWidth = 1;
    const grid = 10; // 10 cells each side
    for(let i=1;i<grid;i++){
      const t = i/grid; const p = Math.floor(t*W)+0.5; mapCtx.beginPath(); mapCtx.moveTo(p,0); mapCtx.lineTo(p,H); mapCtx.stroke(); mapCtx.beginPath(); mapCtx.moveTo(0,p); mapCtx.lineTo(W,p); mapCtx.stroke();
    }
    // roads
    const roadW = 14; // width in meters
    mapCtx.fillStyle = '#3f4449';
    // x-road
    const yRoad = Math.floor(w2mZ(0, size)); const hpx = Math.max(2, Math.floor((roadW/terrainSize)*size));
    mapCtx.fillRect(0, yRoad - hpx/2, size, hpx);
    // z-road
    const xRoad = Math.floor(w2mX(0, size)); const wpx = Math.max(2, Math.floor((roadW/terrainSize)*size));
    mapCtx.fillRect(xRoad - wpx/2, 0, wpx, size);
    // lamps
    if(Array.isArray(lampPositions)){
      mapCtx.fillStyle = '#ffdca8';
      for(const lp of lampPositions){ const px = w2mX(lp.x, size), pz = w2mZ(lp.z, size); mapCtx.fillRect(px-1, pz-1, 2, 2); }
    }
    // utility poles
    if(Array.isArray(utilPoles)){
      mapCtx.fillStyle = '#a8cfff';
      for(const up of utilPoles){ const px = w2mX(up.head.position.x, size), pz = w2mZ(up.head.position.z, size); mapCtx.fillRect(px-1, pz-1, 2, 2); }
    }
    // barricades
    if(Array.isArray(barricadePositions)){
      mapCtx.fillStyle = '#c0c5cc';
      for(const bp of barricadePositions){ const px = w2mX(bp.x, size), pz = w2mZ(bp.z, size); mapCtx.fillRect(px-1, pz-1, 2, 2); }
    }
    // signs
    if(signGroup && signGroup.children){ mapCtx.fillStyle = '#e6f2ff'; signGroup.children.forEach(s=>{ const px=w2mX(s.position.x,size), pz=w2mZ(s.position.z,size); mapCtx.fillRect(px-1,pz-1,2,2); }); }
    // cars
    if(carGroup && carGroup.children){ mapCtx.fillStyle = '#ff6b6b'; carGroup.children.forEach(c=>{ const px=w2mX(c.position.x,size), pz=w2mZ(c.position.z,size); mapCtx.fillRect(px-2,pz-2,4,4); }); }
    // player arrow
    const px = w2mX(camera.position.x, size), pz = w2mZ(camera.position.z, size);
    const ang = yaw; // Y-axis yaw
    const len = 10;
    const ax = Math.cos(ang), az = Math.sin(ang);
    mapCtx.fillStyle = '#ffffff'; mapCtx.strokeStyle = '#ffffff';
    mapCtx.beginPath();
    mapCtx.moveTo(px + ax*len, pz + az*len);
    mapCtx.lineTo(px - az*6, pz + ax*6);
    mapCtx.lineTo(px + az*6, pz - ax*6);
    mapCtx.closePath(); mapCtx.fill();
    // border
    mapCtx.strokeStyle = 'rgba(255,255,255,0.25)'; mapCtx.lineWidth = 2; mapCtx.strokeRect(1,1,size-2,size-2);
  }

  // minimap (always-on, bottom-right)
  const miniWrap = document.createElement('div');
  miniWrap.id = 'minimap';
  Object.assign(miniWrap.style, { position:'fixed', right:'12px', bottom:'12px', zIndex:'9998', pointerEvents:'none' });
  const miniCanvas = document.createElement('canvas'); const miniCtx = miniCanvas.getContext('2d'); miniWrap.appendChild(miniCanvas); document.body.appendChild(miniWrap);
  function sizeMiniMapCanvas(){
    const s = Math.max(140, Math.min(260, Math.floor(Math.min(window.innerWidth, window.innerHeight)*0.22)));
    miniCanvas.width = s; miniCanvas.height = s;
    miniCanvas.style.border = '1px solid rgba(255,255,255,0.25)'; miniCanvas.style.boxShadow = '0 0 12px rgba(0,0,0,0.5)';
  }
  sizeMiniMapCanvas();
  function drawMiniMap(){
    const W = miniCanvas.width, H = miniCanvas.height; const size = W;
    miniCtx.clearRect(0,0,W,H);
    // background
    miniCtx.fillStyle = 'rgba(10,12,14,0.9)'; miniCtx.fillRect(0,0,W,H);
    // roads
    const roadW = 14; miniCtx.fillStyle = '#3f4449';
    const yRoad = Math.floor(w2mZ(0, size)); const hpx = Math.max(2, Math.floor((roadW/terrainSize)*size)); miniCtx.fillRect(0, yRoad - hpx/2, size, hpx);
    const xRoad = Math.floor(w2mX(0, size)); const wpx = Math.max(2, Math.floor((roadW/terrainSize)*size)); miniCtx.fillRect(xRoad - wpx/2, 0, wpx, size);
    // player arrow
    const px = w2mX(camera.position.x, size), pz = w2mZ(camera.position.z, size);
    const ang = yaw; const len = 8; const ax = Math.cos(ang), az = Math.sin(ang);
    miniCtx.fillStyle = '#ffffff'; miniCtx.beginPath();
    miniCtx.moveTo(px + ax*len, pz + az*len);
    miniCtx.lineTo(px - az*5, pz + ax*5);
    miniCtx.lineTo(px + az*5, pz - ax*5);
    miniCtx.closePath(); miniCtx.fill();
    // border
    miniCtx.strokeStyle = 'rgba(255,255,255,0.2)'; miniCtx.lineWidth = 1; miniCtx.strokeRect(0.5,0.5,size-1,size-1);
  }

  // pointer lock button
  const startBtn = document.getElementById('startBtn');
  startBtn.addEventListener('click', ()=>{
    document.body.requestPointerLock();
    startAudio();
    document.getElementById('overlay').style.display = 'none';
  });

  // audio: wind only (no birds) for post-apocalypse
  let audioStarted = false;
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  function createNoiseBuffer(duration){
    const rate = audioCtx.sampleRate; const buf = audioCtx.createBuffer(1, rate*duration, rate);
    const data = buf.getChannelData(0); for(let i=0;i<data.length;i++) data[i] = (Math.random()*2-1)*0.4; return buf;
  }
  function startAudio(){
    if(audioStarted) return; audioStarted = true;
    // 一部ブラウザでの自動停止対策
    if(audioCtx.state === 'suspended'){
      try{ audioCtx.resume(); }catch(e){}
    }
    const noise = audioCtx.createBufferSource(); noise.buffer = createNoiseBuffer(2.0); noise.loop = true;
    const lp = audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=500;
    const hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=80;
    const gain = audioCtx.createGain(); gain.gain.value = 0.12;
    noise.connect(lp); lp.connect(hp); hp.connect(gain); gain.connect(audioCtx.destination); noise.start();
  }

  // spark sound (short, noisy, bright)
  function playSparkAt(pos){
    // simple one-shot using white noise shaped with bandpass and exponential decay
    const src = audioCtx.createBufferSource(); src.buffer = createNoiseBuffer(0.2); src.loop = false;
    const bp = audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value = 3500; bp.Q.value = 3.5;
    const g = audioCtx.createGain(); g.gain.value = 0.18;
    const t = audioCtx.currentTime;
    g.gain.setValueAtTime(0.18, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.15);
    src.connect(bp); bp.connect(g); g.connect(audioCtx.destination); src.start();
  }

  // footstep (short thump + noise), non-spatial for simplicity
  function playFootstep(strength=1.0){
    const t = audioCtx.currentTime;
    // thump: sine burst
    const osc = audioCtx.createOscillator();
    const og = audioCtx.createGain();
    osc.type = 'sine'; osc.frequency.value = 95 + Math.random()*55; // 95-150 Hz
    og.gain.setValueAtTime(0.0, t);
    og.gain.linearRampToValueAtTime(0.16 * strength, t + 0.008);
    og.gain.exponentialRampToValueAtTime(0.001, t + 0.14);
    osc.connect(og);
    // grit: short noise through bandpass
    const ns = audioCtx.createBufferSource(); ns.buffer = createNoiseBuffer(0.12);
    const bp = audioCtx.createBiquadFilter(); bp.type = 'bandpass'; bp.frequency.value = 900 + Math.random()*800; bp.Q.value = 0.7 + Math.random()*0.8;
    const ng = audioCtx.createGain(); ng.gain.setValueAtTime(0.07 * strength, t); ng.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
    ns.connect(bp); bp.connect(ng);
    // master for the step
    const g = audioCtx.createGain(); g.gain.value = 0.16 * Math.min(1.4, Math.max(0.5, strength)); // overall step volume
    og.connect(g); ng.connect(g); g.connect(audioCtx.destination);
    osc.start(t); osc.stop(t + 0.16);
    ns.start(t); ns.stop(t + 0.14);
  }

  // loop
  const clock = new THREE.Clock();
  let timeElapsed = 0;
  // 足音: 距離ベースの歩幅でトリガー
  let stepAcc = 0; // 累積移動距離（m）
  function animate(){
    requestAnimationFrame(animate);
    const dt = Math.min(0.05, clock.getDelta());
    timeElapsed += dt;
    const forward = new Vector3(); camera.getWorldDirection(forward); forward.y=0; forward.normalize();
    const right = new Vector3().crossVectors(forward, new Vector3(0,1,0)).normalize();

  // スタミナと速度倍率（ダッシュ／疲労）
  let speedMul = slowMultiplier; // 新デフォルト歩行=旧鈍足
  if(exhausted){
    // 疲労中は鈍足、ダッシュ不可。スタミナ満タンで解除
    dashTime = 0; // 残りダッシュを即座に無効化
    speedMul = slowMultiplier;
    stamina = Math.min(staminaMax, stamina + staminaRegenRate*dt);
    if(stamina >= staminaMax){ exhausted = false; }
  } else {
    // 通常時: ダッシュ残時間／クールダウン
    if(dashTime>0){ speedMul = dashMultiplier; dashTime -= dt; }
    if(dashCooldown>0) dashCooldown -= dt;
    // 押下ダッシュ中はスタミナを継続消費。0 到達で疲労突入
    if(dashHeld){
      const use = staminaUseRate * dt;
      stamina = Math.max(0, stamina - use);
      if(stamina > 0){
        speedMul = Math.max(speedMul, dashMultiplier); // 1.0 まで上げる=旧歩行
      } else {
        exhausted = true; dashTime = 0; // 枯渇で即疲労化
      }
    } else {
      stamina = Math.min(staminaMax, stamina + staminaRegenRate*dt);
    }
  }

    const targetDir = new Vector3(); if(move.forward) targetDir.add(forward); if(move.back) targetDir.sub(forward); if(move.left) targetDir.sub(right); if(move.right) targetDir.add(right); if(targetDir.length()>0) targetDir.normalize();
    const targetVel = targetDir.multiplyScalar(speed*speedMul);
    const dv = new Vector3().subVectors(targetVel, hVel); const dvLen = dv.length(); if(dvLen>0){ const maxA = (targetDir.length()>0?accel:deccel)*dt; const change = Math.min(maxA, dvLen); hVel.add(dv.normalize().multiplyScalar(change)); }
  const moveStep = hVel.clone().multiplyScalar(dt);
  // tentative horizontal move with collision resolution against static colliders
  if(moveStep.x !== 0 || moveStep.z !== 0){
    const tentative = camera.position.clone();
    tentative.x += moveStep.x; tentative.z += moveStep.z;
    resolveCollisionsXZ(tentative, playerRadius);
    camera.position.x = tentative.x; camera.position.z = tentative.z;
  }
  const horizSpeed = hVel.length();

    velocityY += gravity*dt; camera.position.y += velocityY*dt;
    const groundY = 0; const eyeHeight = 1.6; const targetY = groundY + eyeHeight;
  if(camera.position.y <= targetY){ camera.position.y = targetY; velocityY = 0; grounded = true; }
    else { grounded = false; const damping = 6.0; camera.position.y += (targetY - camera.position.y) * Math.min(1, damping*dt); }

    // streetlight flicker update
    const camPos = camera.position;
    // chunk-based visibility helper
    const camCX = Math.floor(camPos.x / CHUNK_SIZE), camCZ = Math.floor(camPos.z / CHUNK_SIZE);
    function inDrawChunks(x, z){
      const cx = Math.floor(x / CHUNK_SIZE), cz = Math.floor(z / CHUNK_SIZE);
      return Math.abs(cx - camCX) <= drawChunkRadius && Math.abs(cz - camCZ) <= drawChunkRadius;
    }

    const lightActiveRange = 180; // keep light update threshold as safety
    for(let i=0;i<lampLights.length;i++){
      const light = lampLights[i]; const head = lampMeshes[i]; const f = lampFlick[i];
      const near = inDrawChunks(light.position.x, light.position.z);
      if(!near){ light.visible = false; if(head) head.visible = false; continue; }
      light.visible = true; if(head) head.visible = true;
      const outage = (Math.random() < f.offProb*dt) ? 0.0 : 1.0;
      const wave = 0.6 + 0.4*Math.abs(Math.sin(timeElapsed*f.speed + f.jitter));
      light.intensity = f.base * wave * outage;
      if (head && head.material) head.material.emissiveIntensity = 0.5 + 0.7*wave*outage;
    }

    // dust gentle drift
    const pAttr = dustGeo.getAttribute('position');
    for(let i=0;i<dustCount; i++){
      const ix = i*3, iy = ix+1, iz = ix+2;
      let x = pAttr.array[ix], y = pAttr.array[iy], z = pAttr.array[iz];
      x += Math.sin((i*13.1 + timeElapsed*0.3))*0.02;
      z += Math.cos((i*7.7 + timeElapsed*0.27))*0.02;
      y += (Math.sin((i*5.3 + timeElapsed*0.8))*0.003);
      // wrap to keep near origin
      if(x>baseXZ) x=-baseXZ; if(x<-baseXZ) x=baseXZ; if(z>baseXZ) z=-baseXZ; if(z<-baseXZ) z=baseXZ;
      pAttr.array[ix]=x; pAttr.array[iy]=y; pAttr.array[iz]=z;
    }
    pAttr.needsUpdate = true;

  const coordsEl = document.getElementById('coords'); if(coordsEl){ coordsEl.textContent = `x:${camera.position.x.toFixed(2)} y:${camera.position.y.toFixed(2)} z:${camera.position.z.toFixed(2)}`; }
    const stBar = document.getElementById('stamina-bar');
    if(stBar){
      const ratio = Math.max(0, Math.min(1, stamina / staminaMax));
      stBar.style.width = `${ratio * 100}%`;
      const dashActive = (!exhausted) && ((dashTime>0) || (dashHeld && stamina>0));
      // 色分岐: 疲労中はグレー、ダッシュ中はシアン、低スタミナは警告色
      if(exhausted){
        stBar.style.background = 'linear-gradient(90deg,#bbb,#777)';
      } else if(dashActive){
        stBar.style.background = 'linear-gradient(90deg,#6ff,#0cf)';
      } else if(ratio < 0.1){
        stBar.style.background = 'linear-gradient(90deg,#f66,#d00)';
      } else if(ratio < 0.3){
        stBar.style.background = 'linear-gradient(90deg,#fc6,#f80)';
      } else {
        stBar.style.background = 'linear-gradient(90deg,#7cf,#06f)';
      }
    }
    const hpBar = document.getElementById('health-bar');
    if(hpBar){
      const ratio = Math.max(0, Math.min(1, health / healthMax));
      hpBar.style.width = `${ratio * 100}%`;
      // color: green -> yellow -> red
      const r = Math.floor(255 * (1 - ratio));
      const g = Math.floor(200 * (0.4 + 0.6*ratio));
      const color = `rgb(${r}, ${g}, 40)`;
      hpBar.style.background = color;
      const hpText = document.getElementById('health-text');
      if(hpText) hpText.textContent = `${Math.round(health)} / ${Math.round(healthMax)}`;
    }

    // 足音: 地上かつ移動時、移動距離で歩幅を超えたら再生
    if(audioStarted && grounded && horizSpeed > 0.2){
      stepAcc += horizSpeed * dt; // m/frame
      const dashActive = (!exhausted) && ((dashTime>0) || (dashHeld && stamina>0));
      const stride = exhausted ? 1.9 : (dashActive ? 1.2 : 1.8);
      const strength = exhausted ? 0.8 : (dashActive ? 1.2 : 1.0);
      if(stepAcc >= stride){
        playFootstep(strength);
        stepAcc -= stride;
      }
    } else {
      // 立ち止まり・空中ではリセット（次の一歩を安定化）
      stepAcc = 0;
    }

  // update maps
  if(mapVisible){ drawMap(); }
  drawMiniMap();

  // update enemies (wander + sway). Chunk-based visibility.
    if(mistMat && mistMat.uniforms) mistMat.uniforms.time.value = timeElapsed;
    for(let i=0;i<enemies.length;i++){
      const e = enemies[i]; const n = e.node;
      // visibility by chunk
      if(!inDrawChunks(n.position.x, n.position.z)){ n.visible = false; continue; } else { n.visible = true; }
      // simple wander
      e.t += dt; e.sway += dt*1.3;
      // drift direction
      e.dir += (Math.sin(e.t*0.2 + i)*0.4 + Math.sin(e.t*0.5 + i*1.7)*0.25) * 0.05 * dt;
      const sp = e.speed * (0.4 + 0.6*Math.abs(Math.sin(e.sway)));
      const mx = Math.cos(e.dir) * sp * dt;
      const mz = Math.sin(e.dir) * sp * dt;
      const tentative = n.position.clone(); tentative.x += mx; tentative.z += mz;
      resolveCollisionsXZ(tentative, 0.4); // enemy avoids solids similarly
      n.position.x = tentative.x; n.position.z = tentative.z;
      // face camera a bit (for creepiness)
      n.lookAt(camera.position.x, n.position.y + 1.0, camera.position.z);
    }

  // neon flicker + occasional spark (distance-cull updates)
    const neonRange = 140;
    for(let i=0;i<neonMeshes.length;i++){
      const m = neonMeshes[i]; const c = neonCtrl[i];
      if(!inDrawChunks(m.position.x, m.position.z)){ m.visible = false; continue; }
      m.visible = true;
      const outage = (Math.random() < c.offProb*dt) ? 0.0 : 1.0;
      const wave = 0.4 + 0.6*Math.abs(Math.sin(timeElapsed*c.speed + c.jitter));
      const intensity = c.base * wave * outage;
      if(m.material && m.material.emissiveIntensity !== undefined){ m.material.emissiveIntensity = intensity; }
      // try to spark occasionally when intensity rises
      c.nextSpark -= dt;
      if(c.nextSpark <= 0 && outage>0.0 && Math.random()<0.08){
        c.nextSpark = 1.5 + Math.random()*3.0;
        spawnSparkParticles(new Vector3(m.position.x, 0.6, m.position.z));
        // play short spark sfx
        if(audioStarted) playSparkAt(m.position);
      }
    }

    // utility poles arcing (distance-cull)
    const poleRange = 160;
    for(let i=0;i<utilPoles.length;i++){
      const p = utilPoles[i];
      if(!inDrawChunks(p.head.position.x, p.head.position.z)){ p.light.visible=false; p.head.visible=false; continue; }
      p.light.visible = true; p.head.visible = true;
      const c = p.ctrl;
      const outage = (Math.random() < c.offProb*dt) ? 0.0 : 1.0;
      const wave = 0.6 + 0.4*Math.abs(Math.sin(timeElapsed*c.speed + c.jitter));
      const intensity = c.base * wave * outage;
      p.light.intensity = intensity;
      if(p.head.material) p.head.material.emissiveIntensity = intensity*0.8;
      c.nextSpark -= dt;
      if(c.nextSpark <= 0 && outage>0.0 && Math.random()<0.1){
        c.nextSpark = 1.8 + Math.random()*3.0;
        spawnSparkParticles(new Vector3(p.head.position.x, p.head.position.y, p.head.position.z));
        if(audioStarted) playSparkAt(p.head.position);
      }
    }

    // simulate spark particles
    for(let i=sparkBursts.length-1; i>=0; i--){
      const p = sparkBursts[i];
      const posAttr = p.geometry.getAttribute('position');
      const velAttr = p.geometry.getAttribute('velocity');
      const N = posAttr.count;
      p.userData.age += dt; const life = p.userData.life;
      const fade = Math.max(0, 1 - p.userData.age / life);
      if(p.material) p.material.opacity = 0.8 * fade;
      for(let j=0;j<N;j++){
        const ix = j*3;
        velAttr.array[ix+0] *= (1 - 0.9*dt); // horizontal damping
        velAttr.array[ix+2] *= (1 - 0.9*dt);
        velAttr.array[ix+1] += (-9.8) * dt; // gravity
        posAttr.array[ix+0] += velAttr.array[ix+0] * dt;
        posAttr.array[ix+1] += velAttr.array[ix+1] * dt;
        posAttr.array[ix+2] += velAttr.array[ix+2] * dt;
        // clamp to ground
        if(posAttr.array[ix+1] < 0.02){ posAttr.array[ix+1] = 0.02; velAttr.array[ix+1] *= -0.2; }
      }
      posAttr.needsUpdate = true; velAttr.needsUpdate = true;
      if(p.userData.age >= life){ scene.remove(p); sparkBursts.splice(i,1); }
    }

    // billboard the moon toward camera and keep it far
    if(moon){
      moon.lookAt(camera.position.x, camera.position.y, camera.position.z);
      const dirToMoon = new THREE.Vector3(-1, 0.5, -1).normalize();
      const baseDist = 1000;
      moon.position.copy(camera.position).addScaledVector(dirToMoon, baseDist).setY(camera.position.y + 420);
    }

    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener('resize', ()=>{ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
  window.addEventListener('resize', sizeMiniMapCanvas);
})();
  </script>
  <script>
    (function(){
      const btn = document.getElementById('fullscreen-toggle');
      const target = document.body;
      btn.addEventListener('click', ()=>{
        if(!document.fullscreenElement){
          (target.requestFullscreen || target.webkitRequestFullscreen).call(target);
        } else {
          (document.exitFullscreen || document.webkitExitFullscreen).call(document);
        }
      });
    })();
  </script>
</body>
</html>