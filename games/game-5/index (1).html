<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Forest FPS MVP</title>
  <link rel="stylesheet" href="styles (1).css">
</head>
<body>
  <!-- タイトル画面（ゲーム開始前にのみ表示） -->
  <div id="title-screen" style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:radial-gradient(circle at top,#243b6b,#050711 60%,#000);font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;color:#fff;z-index:99999;">
    <div style="position:fixed;left:-20%;right:-20%;height:120px;background:linear-gradient(to bottom,rgba(180,220,255,0.03),rgba(0,0,0,0));transform:translateY(-100%);animation:scan 5s linear infinite;pointer-events:none;"></div>
    <style>
      @keyframes scan{0%{transform:translateY(-100%);}100%{transform:translateY(120vh);}}
    </style>
    <div style="background:rgba(4,6,16,0.8);border-radius:12px;padding:18px 20px 16px;box-shadow:0 0 25px rgba(0,0,0,0.6);border:1px solid rgba(120,190,255,0.5);min-width:260px;backdrop-filter:blur(8px);text-align:center;">
      <h1 style="margin:0 0 12px;font-size:32px;letter-spacing:0.08em;text-transform:uppercase;text-shadow:0 0 14px rgba(71,151,255,0.9);">Neon Rooftop Escape</h1>
      <div style="font-size:13px;opacity:0.8;margin-bottom:32px;">Game-5 / Cyberpunk Night Walk</div>
      <button id="title-start-btn" style="width:100%;padding:9px 10px;margin-top:4px;border-radius:8px;border:0;background:linear-gradient(90deg,#3b82f6,#22c1c3);color:#fff;font-weight:700;font-size:15px;cursor:pointer;box-shadow:0 0 14px rgba(59,130,246,0.7);">ゲームを開始する</button>
      <div style="font-size:11px;opacity:0.8;margin-top:10px;line-height:1.6;">
        操作: WASDで移動 / マウスで視点 / Spaceでジャンプ / Shiftでダッシュ<br>
        E: インタラクト / I: インベントリ / M: マップ / O: 設定
      </div>
    </div>
    <div style="position:fixed;left:10px;bottom:10px;font-size:11px;opacity:0.6;">TKKGamers - Game-5 Prototype</div>
  </div>
  <!-- ゲーム開始用オーバーレイ（タイトル開始後に表示） -->
  <div id="overlay" style="display:none;">
  <button id="startBtn">クリックして開始（Pointer Lock）</button>
  <button id="fullscreen-toggle" aria-label="フルスクリーン切替" style="margin-left:8px">⤢</button>
  <div id="hint">WASD 移動 ・ マウスで視点 ・ Eで拾う/アクション ・ Iでインベントリ ・ Shiftでダッシュ（スタミナ消費・自動回復） ・ Mでマップ</div>
  </div>
  <div id="hud" style="position:fixed;left:12px;top:12px;color:#022;font-weight:700;background:rgba(255,255,255,0.85);padding:6px 10px;border-radius:6px">Score: <span id="score">0</span>
    <div id="coords" style="font-weight:400;margin-top:6px;font-size:12px">x:0.00 y:0.00 z:0.00</div>
  </div>
  <!-- Stamina bar (top center) -->
  <div id="stamina-wrap" style="position:fixed;left:50%;transform:translateX(-50%);top:8px;width:40%;max-width:600px;">
    <div style="background:rgba(0,0,0,0.55);padding:6px;border-radius:8px;color:#fff;font-size:13px;text-align:center">Stamina</div>
    <div style="background:rgba(0,0,0,0.25);height:10px;border-radius:6px;margin-top:6px">
      <div id="stamina-bar" style="height:100%;width:100%;background:linear-gradient(90deg,#7cf,#06f);border-radius:6px;transform-origin:left"></div>
    </div>
  </div>
  <!-- Health (bottom-left, large rectangular bar, no label) -->
  <div id="health-wrap" style="position:fixed;left:12px;bottom:12px;z-index:9999;">
    <div id="battery-wrap" style="position:absolute;left:0;bottom:36px;width:260px;height:18px;background:rgba(255,255,255,0.95);border-radius:2px;box-shadow:0 2px 6px rgba(0,0,0,0.25);outline:1px solid rgba(0,0,0,0.25);display:flex;gap:4px;align-items:center;padding:2px 6px;">
      <div style="font-size:12px;color:#111;font-weight:700;margin-right:6px">Battery</div>
      <div id="bat-cell-1" style="flex:1;height:10px;border-radius:2px;background:#2ecc71;opacity:1"></div>
      <div id="bat-cell-2" style="flex:1;height:10px;border-radius:2px;background:#2ecc71;opacity:1"></div>
      <div id="bat-cell-3" style="flex:1;height:10px;border-radius:2px;background:#2ecc71;opacity:1"></div>
    </div>
    <div id="health-bar-wrap" style="position:relative;background:rgba(255,255,255,0.95);height:28px;border-radius:2px;margin-top:0;width:420px;box-shadow:0 3px 8px rgba(0,0,0,0.35);outline:1px solid rgba(0,0,0,0.25)">
      <div id="health-bar" style="height:100%;width:100%;background:#d33;border-radius:2px;transform-origin:left;transition:width 0.08s linear"></div>
      <div id="health-text" style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-size:14px;color:#111;font-weight:800;text-shadow:0 1px 1px rgba(255,255,255,0.7)">100 / 100</div>
    </div>
  </div>
  <script type="module">
// game-5 urban step1: asphalt ground + roads, overcast mood
(async function(){
  let THREE;
  // ローカルのthree.jsには依存せず、常にCDNモジュールのみを使用して404やMIMEエラーを避ける
  THREE = await import('https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js');
  // 物理エンジン cannon-es をCDNから読み込み（最小構成：地面とプレイヤー球体）
  const CANNON = await import('https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js');
  const { Scene, PerspectiveCamera, WebGLRenderer, Color, FogExp2, DirectionalLight, AmbientLight, HemisphereLight, PlaneGeometry, MeshStandardMaterial, Mesh, Vector3, CanvasTexture, CylinderGeometry, InstancedMesh, PointLight, BoxGeometry, BufferGeometry, Points, PointsMaterial, Group, ConeGeometry, MeshBasicMaterial, DoubleSide, ShaderMaterial } = THREE;
  // 外部マップ（GLTF）を優先するフラグ
  const useExternalMap = true;
  // GLTFLoader をESM CDNから読み込み（bare specifier 'three' を解決するため esm.sh を使用）
  const { GLTFLoader } = await import('https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/GLTFLoader.js');

  // --- 物理ワールド（cannon-es）最小セットアップ ---
  const world = new CANNON.World({
    gravity: new CANNON.Vec3(0, -25, 0) // ゲーム内の gravity = -25 に揃える
  });
  // 地面平面（いまは単純な Plane。必要ならBoxに変更可）
  const groundBody = new CANNON.Body({ mass: 0 });
  groundBody.addShape(new CANNON.Plane());
  // three.js の地面と同じく Y+ が上になるように回転（法線を +Y に）
  groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
  world.addBody(groundBody);

  // --- ゲーム状態 & タイトル制御 ---
  const titleScreen = document.getElementById('title-screen');
  const titleStartBtn = document.getElementById('title-start-btn');
  const overlay = document.getElementById('overlay');
  let gameStarted = false; // Pointer Lock 前のタイトル/チュートリアル状態

  function showTitle(){
    gameStarted = false;
    if(titleScreen) titleScreen.style.display = 'flex';
    if(overlay) overlay.style.display = 'none';
  }

  function showOverlayForPointerLock(){
    if(titleScreen) titleScreen.style.display = 'none';
    if(overlay) overlay.style.display = 'block';
  }

  // タイトルの「ゲームを開始する」ボタンと Enter キーでゲーム開始オーバーレイへ
  if(titleStartBtn){
    titleStartBtn.addEventListener('click', ()=>{
      showOverlayForPointerLock();
    });
  }
  window.addEventListener('keydown', (e)=>{
    if(!gameStarted && (e.key === 'Enter' || e.code === 'Enter')){
      showOverlayForPointerLock();
    }
  });

  // Pointer Lock 開始ボタンを押したら本当のゲーム開始状態とみなす
  const startBtnEl = document.getElementById('startBtn');
  if(startBtnEl){
    startBtnEl.addEventListener('click', ()=>{
      gameStarted = true;
      // overlay自体はPointer Lock用の説明としてそのままでもよいが、視界をクリアにするため非表示
      overlay.style.display = 'none';
    });
  }

  // scene & renderer (cyberpunk midnight)
  const scene = new Scene();
  const skyCol = new Color(0x04070c); // deeper near-black blue to make neon pop
  scene.background = skyCol;
  // thicker colored haze picking up magenta/blue neon scatter
  scene.fog = new FogExp2(0x070912, 0.014);

  const camera = new PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 6000);
  // 初期スポーン（後でランドマーク生成後に屋上へ再配置）
  const spawnPoint = new THREE.Vector3(0, 1.6, 28);
  camera.position.copy(spawnPoint);
  // Predeclare interactables & pickup group early so spawners can run before later blocks initialize
  const interactables = [];
  const pickupGroup = new Group(); scene.add(pickupGroup);
  // First-person arms (enhanced hands with fingers)
  const armsGroup = new Group();
  const armMat = new MeshStandardMaterial({ color: 0xcccccc, roughness: 0.9, metalness: 0.0 });
  const upperGeo = new BoxGeometry(0.12, 0.36, 0.12);
  const lowerGeo = new BoxGeometry(0.11, 0.34, 0.11);
  const handGeo  = new BoxGeometry(0.16, 0.10, 0.20);
  // fingered hand builder (uses helper fns defined later: makeLimbCyl, makePalmBox)
  function buildFPHand(side='R', mat){
    const handRoot = new Group();
    const skinMat = (mat||armMat).clone();
    // slight skin tint
    skinMat.color = new Color(0xffd6bd);
    skinMat.roughness = 0.8; skinMat.metalness = 0.0;
    const palm = new Mesh(makePalmBox(0.16, 0.05, 0.18), skinMat);
    handRoot.add(palm);
    const isLeft = side === 'L';
    const sgn = isLeft ? 1 : -1;
    const bases = [
      {x: sgn*0.038, z:-0.02, yaw: sgn*0.42}, // thumb (対立させるため大きめyaw)
      {x: sgn*0.026, z: 0.00, yaw: 0.00},     // index
      {x: sgn*0.000, z: 0.01, yaw: 0.00},     // middle
      {x: sgn*-0.020, z: 0.00, yaw: 0.00},    // ring
      {x: sgn*-0.036, z:-0.01, yaw: 0.00},    // little
    ];
    const fingers = [];
  for(let i=0;i<5;i++){
      const b = bases[i];
      const base = new Group();
      base.position.set(b.x, -0.015, 0.06 + b.z);
      base.rotation.y = b.yaw;
      handRoot.add(base);
      const prox = new Mesh(makeLimbCyl(0.11, 0.035, 0.045), skinMat); base.add(prox);
      const midG = new Group(); midG.position.set(0, -0.095, 0); base.add(midG);
      const mid = new Mesh(makeLimbCyl(0.10, 0.03, 0.04), skinMat); midG.add(mid);
      const tipG = new Group(); tipG.position.set(0, -0.085, 0); midG.add(tipG);
  const tip = new Mesh(makeLimbCyl(0.09, 0.028, 0.035), skinMat); tipG.add(tip);
  fingers.push({ base, midG, tipG, isThumb: i===0, baseYaw: b.yaw });
    }
    return { root: handRoot, fingers };
  }
  // Left arm (for flashlight)
  const leftShoulder = new Group();
  const leftUpper = new Mesh(upperGeo, armMat.clone());
  const leftElbow = new Group();
  const leftLower = new Mesh(lowerGeo, leftUpper.material);
  const leftWrist = new Group();
  // Left hand: switch to articulated hand group
  const leftHand = new Group();
  leftShoulder.add(leftUpper);
  leftShoulder.position.set(-0.34, -0.30, -0.38);
  leftUpper.position.set(0, -0.18, 0);
  leftElbow.position.set(0, -0.36, 0);
  leftUpper.add(leftElbow);
  leftLower.position.set(0, -0.17, 0);
  leftElbow.add(leftLower);
  leftWrist.position.set(0, -0.34, 0.02);
  leftElbow.add(leftWrist);
  leftHand.position.set(-0.01, -0.06, 0.09);
  leftWrist.add(leftHand);
  let leftFingers = [];
  {
    const built = buildFPHand('L', leftUpper.material);
    leftHand.add(built.root);
    leftFingers = built.fingers;
  }
  armsGroup.add(leftShoulder);
  // Flashlight holder (simple cylinder)
  const flashlightGeo = new CylinderGeometry(0.04,0.05,0.22,12);
  flashlightGeo.rotateZ(Math.PI/2);
  const flashlightMat = new MeshStandardMaterial({ color:0x222222, metalness:0.4, roughness:0.6 });
  const flashlightMesh = new Mesh(flashlightGeo, flashlightMat);
  flashlightMesh.position.set(-0.02, -0.04, 0.14);
  leftHand.add(flashlightMesh);
  // Lights (spot + faint point)
  const flashlightSpot = new THREE.SpotLight(0xffffff, 4.0, 18, Math.PI/10, 0.35, 1.0);
  flashlightSpot.castShadow = true;
  flashlightSpot.shadow.mapSize.set(512,512);
  flashlightSpot.shadow.camera.near = 0.1;
  flashlightSpot.shadow.camera.far = 30;
  const flashlightPoint = new THREE.PointLight(0xffffff, 0.6, 2.4, 2.0);
  flashlightSpot.position.set(0,0,0); flashlightPoint.position.set(0,0,0);
  const flashlightTarget = new THREE.Object3D();
  scene.add(flashlightTarget);
  flashlightSpot.target = flashlightTarget;
  flashlightMesh.add(flashlightSpot); flashlightMesh.add(flashlightPoint);
  // Battery system
  let batterySegments = 3; // current filled segments (0..3)
  const batteryMaxSegments = 3;
  let batteryDrainRate = 0.12; // segments per minute equivalent scaled inside loop
  let batteryAccum = 0; // drains to reduce segments
  const rightShoulder = new Group();
  const rightUpper = new Mesh(upperGeo, armMat);
  const rightElbow = new Group();
  const rightLower = new Mesh(lowerGeo, armMat);
  const rightWrist = new Group();
  // Right hand: switch to articulated hand group
  const rightHand  = new Group();
  rightShoulder.add(rightUpper);
  rightShoulder.position.set(0.32, -0.28, -0.36);
  rightUpper.position.set(0, -0.18, 0);
  rightElbow.position.set(0, -0.36, 0);
  rightUpper.add(rightElbow);
  rightLower.position.set(0, -0.17, 0);
  rightElbow.add(rightLower);
  rightWrist.position.set(0, -0.33, 0.02);
  rightElbow.add(rightWrist);
  rightHand.position.set(0.01, -0.06, 0.09);
  rightWrist.add(rightHand);
  let rightFingers = [];
  {
    const built = buildFPHand('R', armMat);
    rightHand.add(built.root);
    rightFingers = built.fingers;
  }
  armsGroup.add(rightShoulder);
  armsGroup.rotation.x = -0.25; armsGroup.rotation.y = 0.15;
  camera.add(armsGroup);
  scene.add(camera);
  let armBob = 0; let armReachT = 0;

  const renderer = new WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  // push exposure slightly for vivid emissives; use ACES for cinematic rolloff if available
  if(renderer.toneMapping !== undefined){
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.25;
  }
  document.body.appendChild(renderer.domElement);

  // lights (cool ambient upper sky tint + warm ground bounce)
  const hemi = new HemisphereLight(0x314e80, 0x120910, 0.32);
  scene.add(hemi);
  const sun = new DirectionalLight(0x4477bb, 0.18); // dim moon / skyline scatter
  sun.position.set(-120, 160, -60);
  sun.castShadow = true;
  sun.shadow.mapSize.set(1024,1024);
  sun.shadow.camera.near = 0.5; sun.shadow.camera.far = 600;
  sun.shadow.camera.left = -200; sun.shadow.camera.right = 200; sun.shadow.camera.top = 200; sun.shadow.camera.bottom = -200;
  scene.add(sun);
  scene.add(new AmbientLight(0x18202c, 0.10));

  // helpers: canvas textures
  function makeNoiseCanvas(w=512, h=512, base=68, amp=14){
    const c = document.createElement('canvas'); c.width=w; c.height=h;
    const ctx = c.getContext('2d');
    const img = ctx.createImageData(w,h);
    const d = img.data;
    for(let i=0;i<w*h;i++){
      const n = base + Math.floor((Math.random()*2-1) * amp); // grey with noise
      const o = i*4; d[o]=n; d[o+1]=n; d[o+2]=n; d[o+3]=255;
    }
    ctx.putImageData(img,0,0);
    return c;
  }
  function makeAsphaltTexture(){
    const base = makeNoiseCanvas(512,512,66,16);
    const ctx = base.getContext('2d');
    // add subtle darker blotches
    ctx.fillStyle = 'rgba(0,0,0,0.08)';
    for(let i=0;i<120;i++){
      const x = Math.random()*512, y = Math.random()*512;
      const r = 10 + Math.random()*40;
      ctx.beginPath(); ctx.ellipse(x,y,r*1.2,r,0,0,Math.PI*2); ctx.fill();
    }
    const tex = new CanvasTexture(base);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.anisotropy = 4;
    tex.needsUpdate = true;
    return tex;
  }
  function makeRoughnessTexture(){
    const base = makeNoiseCanvas(512,512,210,30); // brighter = rougher
    const tex = new CanvasTexture(base);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.anisotropy = 4; tex.needsUpdate = true; return tex;
  }
  function makeRoadTexture({w=1024,h=512, lanes=2, dashed=true}={}){
    const c = document.createElement('canvas'); c.width=w; c.height=h;
    const ctx = c.getContext('2d');
    // base asphalt
    ctx.fillStyle = '#3e4246'; ctx.fillRect(0,0,w,h);
    // sprinkle noise
    const noise = makeNoiseCanvas(w,h,65,18);
    ctx.globalAlpha = 0.35; ctx.drawImage(noise,0,0); ctx.globalAlpha = 1;
    // edge lines
    ctx.fillStyle = '#dfe7ee';
    const edge = Math.floor(h*0.08);
    ctx.fillRect(0, edge, w, Math.max(2, Math.floor(h*0.01)));
    ctx.fillRect(0, h-edge, w, Math.max(2, Math.floor(h*0.01)));
    // center lines
    if(lanes>=2){
      const lineY = Math.floor(h/2)-2;
      ctx.fillStyle = '#e2c03b';
      if(dashed){
        const seg = 40, gap = 28;
        for(let x=0;x<w;x+=seg+gap){ ctx.fillRect(x, lineY, seg, 4); }
      } else {
        ctx.fillRect(0, lineY, w, 4);
      }
    }
    const tex = new CanvasTexture(c);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.anisotropy = 4; tex.needsUpdate = true; return tex;
  }

  // ground (flat with subtle micro undulation)
  const terrainSize = 1000; // 1km x 1km (縮小して密度を濃くしつつパフォーマンス向上)
  const segments = 200;
  const planeGeo = new PlaneGeometry(terrainSize, terrainSize, segments, segments);
  planeGeo.rotateX(-Math.PI/2);
  // slight micro variation to break perfect flatness (<= 0.15m)
  const pos = planeGeo.attributes.position;
  for(let i=0;i<pos.count;i++){
    const x = pos.getX(i), z = pos.getZ(i);
    const n = Math.sin(x*0.08) * Math.cos(z*0.06) * 0.03 + (Math.random()*2-1)*0.02;
    pos.setY(i, n*5.0); // up to ~0.15m
  }
  planeGeo.computeVertexNormals();
  function sampleGroundHeight(){ return 0; } // flat baseline for collision target

  const asphaltMap = makeAsphaltTexture(); asphaltMap.repeat.set(50,50); // 縮尺に合わせてタイル数調整
  const roughMap = makeRoughnessTexture(); roughMap.repeat.set(50,50);
  const groundMat = new MeshStandardMaterial({ color:0x2a2e33, map: asphaltMap, roughnessMap: roughMap, roughness: 1.0, metalness: 0.0 });
  if(!useExternalMap){
    const ground = new Mesh(planeGeo, groundMat);
    ground.receiveShadow = true; scene.add(ground);
  }

  // --- 外部GLTF/GLB 読み込みヘルパー ---
  let externalMapRoot = null;
  let externalCollidableMeshes = [];
  // レイキャスト共有インスタンス & 簡易キャッシュ
  const sharedRaycaster = new THREE.Raycaster();
  let lastGYQuery = { x: Infinity, z: Infinity, y: 0, time: 0 };
  async function loadExternalGLTF(url, { position = new THREE.Vector3(0,0,0), scale = 1.0, rotationY = 0 } = {}){
    const loader = new GLTFLoader();
    return new Promise((resolve, reject)=>{
      loader.load(url, (gltf)=>{
        const root = gltf.scene || gltf.scenes?.[0];
        if(!root){ reject(new Error('GLTF has no scene')); return; }
        const collidable = [];
        root.traverse((obj)=>{ if(obj.isMesh){ obj.castShadow = true; obj.receiveShadow = true; collidable.push(obj); }});
        root.position.copy(position);
        root.scale.setScalar(scale);
        root.rotation.y = rotationY;
        scene.add(root);
        externalMapRoot = root;
        externalCollidableMeshes = collidable;
        resolve(root);
      }, undefined, (err)=>{ reject(err); });
    });
  }

  // ローカルマップを読み込み（games/game-5/map_3d/scene.gltf）
  try{
    await loadExternalGLTF('./map_3d/scene.gltf', {
      position: new THREE.Vector3(0, 0, 0),
      scale: 1.0,
      rotationY: 0
    });
  }catch(err){
    console.warn('GLTF map load failed:', err);
  }

  // roads: two crossing planes forming an intersection
  if(!useExternalMap){
    const roadTex = makeRoadTexture({w:1024,h:512,lanes:2,dashed:true});
    roadTex.repeat.set(72,1);
    const roadMat = new MeshStandardMaterial({ map: roadTex, roughness: 0.95, metalness: 0.0 });
    const roadA = new Mesh(new PlaneGeometry(980, 14, 1, 1), roadMat);
    roadA.rotation.x = -Math.PI/2; roadA.position.y = 0.01; scene.add(roadA);
    const roadB = new Mesh(new PlaneGeometry(14, 980, 1, 1), roadMat);
    roadB.rotation.x = -Math.PI/2; roadB.position.y = 0.011; scene.add(roadB);
  }

  // decals: cracks and oil stains
  function makeCrackTexture(w=512,h=256, branches=18){
    const c = document.createElement('canvas'); c.width=w; c.height=h; const ctx=c.getContext('2d');
    ctx.lineCap='round'; ctx.lineJoin='round';
    for(let b=0;b<branches;b++){
      let x = Math.random()*w, y = Math.random()*h;
      let ang = Math.random()*Math.PI*2; let segs = 10 + Math.floor(Math.random()*20);
      let thick = 1 + Math.random()*2;
      ctx.beginPath(); ctx.moveTo(x,y);
      for(let s=0;s<segs;s++){
        ang += (Math.random()*2-1)*0.6; const len = 6 + Math.random()*18;
        x += Math.cos(ang)*len; y += Math.sin(ang)*len;
        ctx.lineWidth = thick * (1 - s/segs);
        ctx.strokeStyle = 'rgba(10,10,10,0.55)'; ctx.lineTo(x,y); ctx.stroke();
        // small offshoot
        if(Math.random()<0.18){
          const a2 = ang + (Math.random()*2-1)*1.2; const l2 = 4 + Math.random()*10;
          ctx.beginPath(); ctx.moveTo(x,y); ctx.lineWidth = Math.max(0.6, ctx.lineWidth*0.6);
          ctx.strokeStyle = 'rgba(10,10,10,0.45)'; ctx.lineTo(x+Math.cos(a2)*l2, y+Math.sin(a2)*l2); ctx.stroke();
        }
      }
    }
    const tex = new CanvasTexture(c); tex.needsUpdate = true; return tex;
  }
  function makeOilTexture(w=256,h=256, spots=8){
    const c = document.createElement('canvas'); c.width=w; c.height=h; const ctx=c.getContext('2d');
    for(let i=0;i<spots;i++){
      const x = Math.random()*w, y = Math.random()*h; const r = 20 + Math.random()*60;
      const g = ctx.createRadialGradient(x,y, r*0.1, x,y, r);
      g.addColorStop(0, 'rgba(20,20,20,0.6)');
      g.addColorStop(0.6, 'rgba(20,20,20,0.25)');
      g.addColorStop(1, 'rgba(20,20,20,0.0)');
      ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
      // rainbow sheen hint
      if(Math.random()<0.5){
        ctx.globalCompositeOperation='lighter';
        ctx.strokeStyle='rgba(160,120,220,0.08)'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(x,y,r*0.65,0,Math.PI*2); ctx.stroke();
        ctx.globalCompositeOperation='source-over';
      }
    }
    const tex = new CanvasTexture(c); tex.needsUpdate = true; return tex;
  }
  // 屋上タイルテクスチャ
  function makeTileTexture(w=512,h=512, cell=2){
    const c=document.createElement('canvas'); c.width=w; c.height=h; const ctx=c.getContext('2d');
    // ベース
    ctx.fillStyle = '#2a2f36'; ctx.fillRect(0,0,w,h);
    // ノイズで質感
    const noise = makeNoiseCanvas(w,h,70,14); ctx.globalAlpha=0.25; ctx.drawImage(noise,0,0); ctx.globalAlpha=1;
    // グリッド
    const cols = 16, rows = 16; // 正方格子
    ctx.strokeStyle = 'rgba(220,230,240,0.08)'; ctx.lineWidth = 1;
    for(let i=1;i<cols;i++){ const x = Math.floor(i*w/cols)+0.5; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
    for(let j=1;j<rows;j++){ const y = Math.floor(j*h/rows)+0.5; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
    // ランダム目地強調
    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    for(let k=0;k<Math.floor(cols*0.3);k++){
      const i = 1+Math.floor(Math.random()*(cols-1)); const x = Math.floor(i*w/cols)+0.5; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
    }
    const tex = new CanvasTexture(c); tex.wrapS=tex.wrapT=THREE.RepeatWrapping; tex.anisotropy=4; tex.needsUpdate=true; return tex;
  }
  function makeHazardTexture(w=512,h=256){
    const c=document.createElement('canvas'); c.width=w; c.height=h; const ctx=c.getContext('2d');
    ctx.fillStyle='#20252b'; ctx.fillRect(0,0,w,h);
    const stripeW = 28; const colors=['#f2d14a','#252525'];
    for(let x=-w; x<w*2; x+=stripeW){
      ctx.save(); ctx.translate(x,0); ctx.rotate(-Math.PI/6);
      ctx.fillStyle = colors[((x/stripeW)&1)===0?0:1];
      ctx.fillRect(0,-h, stripeW, h*3);
      ctx.restore();
    }
    // 使い込まれた汚れ
    const noise = makeNoiseCanvas(w,h,80,40); ctx.globalAlpha=0.1; ctx.drawImage(noise,0,0); ctx.globalAlpha=1;
    const tex = new CanvasTexture(c); tex.wrapS=tex.wrapT=THREE.RepeatWrapping; tex.anisotropy=4; tex.needsUpdate=true; return tex;
  }
  function addDecal(tex, x, z, w=6, h=2, rot=0, opacity=1){
    const mat = new MeshStandardMaterial({ map: tex, transparent: true, opacity, roughness: 0.95, metalness: 0.0 });
    mat.depthWrite = false; mat.polygonOffset = true; mat.polygonOffsetFactor = -1; mat.polygonOffsetUnits = -1;
    const g = new PlaneGeometry(w,h); const m = new Mesh(g, mat);
    m.rotation.x = -Math.PI/2; m.rotation.z = rot; m.position.set(x, 0.02, z); // lifted slightly to avoid z-fight
    scene.add(m); return m;
  }
  // place decals along roads
  const crackTex = makeCrackTexture();
  const oilTex = makeOilTexture();
  // along x-road (z near 0)
  for(let x=-1200; x<=1200; x+=30){
    if(Math.random()<0.85) addDecal(crackTex, x + (Math.random()*6-3), (Math.random()*6-3), 8, 2.2, Math.random()*0.6-0.3, 0.95);
    if(Math.random()<0.55) addDecal(oilTex, x + (Math.random()*6-3), (Math.random()*6-3), 3.2, 2.2, Math.random()*Math.PI, 0.85);
  }
  // along z-road (x near 0)
  for(let z=-1200; z<=1200; z+=30){
    if(Math.random()<0.85) addDecal(crackTex, (Math.random()*6-3), z + (Math.random()*6-3), 8, 2.2, Math.random()*0.6-0.3, 0.95);
    if(Math.random()<0.55) addDecal(oilTex, (Math.random()*6-3), z + (Math.random()*6-3), 3.2, 2.2, Math.random()*Math.PI, 0.85);
  }

  // puddles (glossy dark planes)
  function makePuddleTexture(w=256,h=256){
    const c = document.createElement('canvas'); c.width=w; c.height=h; const ctx=c.getContext('2d');
    const x=w/2, y=h/2, r=Math.min(w,h)*0.48;
    const g = ctx.createRadialGradient(x,y, r*0.2, x,y, r);
    g.addColorStop(0, 'rgba(30,36,44,0.8)');
    g.addColorStop(1, 'rgba(30,36,44,0.0)');
    ctx.fillStyle = g; ctx.beginPath(); ctx.ellipse(x,y, r*1.0, r*0.7, 0, 0, Math.PI*2); ctx.fill();
    return new CanvasTexture(c);
  }
  const puddleTex = makePuddleTexture();
  function addPuddle(x,z, sx=4, sz=2.6, rot=0){
    const mat = new MeshStandardMaterial({ map: puddleTex, color: 0x23262b, transparent: true, roughness: 0.12, metalness: 0.85, opacity: 0.95 });
    mat.depthWrite = false; mat.polygonOffset = true; mat.polygonOffsetFactor = -1; mat.polygonOffsetUnits = -1;
    const g = new PlaneGeometry(sx,sz); const m = new Mesh(g, mat);
    m.rotation.x = -Math.PI/2; m.rotation.z = rot; m.position.set(x, 0.021, z); scene.add(m); return m;
  }
  for(let i=0;i<40;i++){
    addPuddle((Math.random()*2-1)*480, (Math.random()*2-1)*6, 2.5+Math.random()*3, 1.6+Math.random()*2.0, Math.random()*0.6-0.3);
    addPuddle((Math.random()*2-1)*6, (Math.random()*2-1)*480, 2.5+Math.random()*3, 1.6+Math.random()*2.0, Math.random()*0.6-0.3);
  }

  // far building silhouettes (low-cost instanced boxes)
  const towerCount = 48; // 縮小マップ: 遠景タワー数を削減
  const towerGeo = new BoxGeometry(1,1,1);
  const towerMat = new MeshStandardMaterial({ color: 0x2a2e36, roughness: 1.0, metalness: 0.0 });
  const towerInst = new InstancedMesh(towerGeo, towerMat, towerCount);
  const tDummy = new THREE.Object3D();
  for(let i=0;i<towerCount;i++){
    const ang = Math.random()*Math.PI*2;
  const dist = 520 + Math.random()*420; // 1km境界の内側〜境界付近
    const bx = Math.cos(ang)*dist; const bz = Math.sin(ang)*dist;
    const w = 6 + Math.random()*20; const d = 6 + Math.random()*20; const h = 30 + Math.random()*180;
    tDummy.position.set(bx, h*0.5, bz);
    tDummy.scale.set(w, h, d);
    tDummy.rotation.y = Math.random()*Math.PI;
    tDummy.updateMatrix(); towerInst.setMatrixAt(i, tDummy.matrix);
  }
  towerInst.instanceMatrix.needsUpdate = true; towerInst.castShadow = false; towerInst.receiveShadow = true; scene.add(towerInst);

  // --- modular tower clusters (dense neon megastructures)
  function makeFacadeTexture(w=256, h=512, warmBias=0.55){
    const c = document.createElement('canvas'); c.width = w; c.height = h;
    const ctx = c.getContext('2d');
    ctx.fillStyle = '#10141b'; ctx.fillRect(0, 0, w, h);
    const rows = 28; const cols = 14;
    const warmPalette = ['#ff9a45', '#ff71c5', '#ffd362', '#ff5d91'];
    const coolPalette = ['#42d9ff', '#67b8ff', '#8fe9ff', '#9fa7ff'];
    for(let r=0;r<rows;r++){
      for(let cIdx=0;cIdx<cols;cIdx++){
        if(Math.random()<0.18) continue;
        const cellW = w/cols; const cellH = h/rows;
        const px = cIdx*cellW; const py = r*cellH;
        const palette = (r/rows) < warmBias ? warmPalette : coolPalette;
        const color = palette[Math.floor(Math.random()*palette.length)];
        const ww = cellW * (0.42 + Math.random()*0.28);
        const hh = cellH * (0.45 + Math.random()*0.25);
        ctx.globalAlpha = 0.75 + Math.random()*0.2;
        ctx.fillStyle = color;
        ctx.fillRect(px + (cellW-ww)*0.5, py + (cellH-hh)*0.5, ww, hh);
        if(Math.random()<0.12){
          ctx.globalAlpha = 0.12 + Math.random()*0.15;
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(px + (cellW-ww)*0.5, py + hh*0.6, ww*0.9, hh*0.35);
        }
      }
    }
    const tex = new CanvasTexture(c);
    tex.anisotropy = 2;
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.needsUpdate = true;
    return tex;
  }
  const facadeTexWarm = makeFacadeTexture(256, 512, 0.55);
  const facadeTexCool = makeFacadeTexture(256, 512, 0.35);
  const podiumTemplate = new MeshStandardMaterial({ color: 0x1a2029, roughness: 0.6, metalness: 0.45 });
  const towerTemplateWarm = new MeshStandardMaterial({ color: 0xffffff, map: facadeTexWarm, emissive: 0x141a2b, emissiveMap: facadeTexWarm, emissiveIntensity: 0.9, roughness: 0.78, metalness: 0.32 });
  const towerTemplateCool = towerTemplateWarm.clone(); towerTemplateCool.map = facadeTexCool; towerTemplateCool.emissiveMap = facadeTexCool; towerTemplateCool.emissiveIntensity = 1.05;
  const capTemplate = new MeshStandardMaterial({ color: 0x1b222e, emissive: 0x1c2f4b, emissiveIntensity: 0.6, roughness: 0.66, metalness: 0.4 });
  const spireTemplate = new MeshStandardMaterial({ color: 0x252f3c, emissive: 0x3462ff, emissiveIntensity: 0.7, roughness: 0.5, metalness: 0.65 });
  const neonStripBase = new MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.85, depthWrite: false, blending: THREE.AdditiveBlending, side: DoubleSide });
  const neonPalette = [0x33c8ff, 0xff3fa8, 0x3dff7a, 0xffef55, 0x8f4dff, 0xff2e55, 0x66ffee, 0xffa3d6];

  const unitBox = new BoxGeometry(1,1,1);
  const stripGeo = new PlaneGeometry(1,1);
  const spireGeo = new CylinderGeometry(0.35, 0.6, 4, 8);

  const towerGroup = new Group(); scene.add(towerGroup);
  const bridgeGroup = new Group(); scene.add(bridgeGroup);
  const cityTowers = [];
  let landmarkInfo = null; // 中央ランドマーク情報
  const skybridges = [];

  function cloneMatWithJitter(base, lightJitter=0){
    const mat = base.clone();
    if(lightJitter !== 0) mat.color.offsetHSL(0, 0, lightJitter);
    if(mat.emissiveIntensity !== undefined){ mat.emissiveIntensity *= 0.85 + Math.random()*0.3; }
    mat.roughness = Math.min(1.0, Math.max(0.1, mat.roughness * (0.9 + Math.random()*0.2)));
    mat.metalness = Math.min(1.0, Math.max(0.0, mat.metalness * (0.9 + Math.random()*0.2)));
    return mat;
  }

  // 中心ランドマーク超高層（基準ビル）
  function createLandmarkMegaTower(x=0, z=0){
    const group = new Group();
    group.position.set(x, 0, z);
    towerGroup.add(group);

  // 広いポディウム（交差点を覆う基壇）
  const LM_SCALE = 5;
  const podiumW = 36*LM_SCALE, podiumD = 36*LM_SCALE, podiumH = 10*LM_SCALE;
    const podium = new Mesh(unitBox, cloneMatWithJitter(podiumTemplate, 0));
    podium.scale.set(podiumW, podiumH, podiumD);
    podium.position.y = podiumH * 0.5;
    group.add(podium);

    // メインシャフト（層状セグメント）
  let width = 26*LM_SCALE, depth = 26*LM_SCALE;
    let currentY = podiumH;
  const segHeights = [38, 42, 36, 32, 28].map(h=>h*LM_SCALE);
    const anchors = [];
    const facadeTemplates = [towerTemplateWarm, towerTemplateCool];
    for(let i=0;i<segHeights.length;i++){
      const h = segHeights[i];
      const seg = new Mesh(unitBox, cloneMatWithJitter(facadeTemplates[i % 2], (Math.random()*0.06)-0.03));
      seg.scale.set(width, h, depth);
      seg.position.y = currentY + h*0.5;
      group.add(seg);
      anchors.push(seg.position.y + h*0.35);
      currentY += h;
      width *= 0.9; depth *= 0.9;
    }

    // クラウンとスパイア
  const capH = 20*LM_SCALE;
    const cap = new Mesh(unitBox, cloneMatWithJitter(capTemplate, 0));
    cap.scale.set(width*0.95, capH, depth*0.95);
    cap.position.y = currentY + capH*0.5;
    group.add(cap);
    let topY = cap.position.y + capH*0.5;
    anchors.push(cap.position.y + capH*0.4);

  const spireH = 36*LM_SCALE;
    const spire = new Mesh(spireGeo, cloneMatWithJitter(spireTemplate, 0));
    spire.scale.set(1.4, spireH, 1.4);
    spire.position.y = topY + spireH*0.5;
    group.add(spire);
    topY = spire.position.y + spireH*0.5;

    // 4面ネオンストリップ
    const faces = [0,1,2,3];
    for(const face of faces){
      const stripMat = neonStripBase.clone();
      stripMat.color = new Color(neonPalette[Math.floor(Math.random()*neonPalette.length)]);
      stripMat.opacity = 0.8;
      const strip = new Mesh(stripGeo, stripMat);
      strip.scale.set(Math.max(1.0, podiumW*0.14), topY*0.9, 1);
      strip.position.y = topY*0.5;
      switch(face){
        case 0: strip.position.z = depth*0.5 + 0.2; break;
        case 1: strip.position.z = -depth*0.5 - 0.2; break;
        case 2: strip.position.x = width*0.5 + 0.2; strip.rotation.y = Math.PI/2; break;
        default: strip.position.x = -width*0.5 - 0.2; strip.rotation.y = Math.PI/2; break;
      }
      group.add(strip);
    }

    // 頂部ビーコンライト（控えめ）
  const beacon = new PointLight(0x66e0ff, 1.8, 120, 1.2);
    beacon.castShadow = false;
    beacon.position.set(0, topY + 6, 0);
    group.add(beacon);

    // cityTowers へ登録（コリジョン/ミニマップ用）
  const roofRadius = Math.max(width*0.5, depth*0.5) * 0.9;
  const info = { group, x, z, radius: Math.max(podiumW, podiumD) * 0.6, height: topY, anchors: anchors.slice(-3), roofRadius };
    cityTowers.push(info);
    return info;
  }

  // 指定位置の地面Yを返す（外部GLTFがある場合は見た目に合わせてレイキャスト）
  function getGroundYAt(x, z){
    if(useExternalMap && externalMapRoot){
      // 近距離キャッシュ（1.5m以内・10ms以内なら再利用）
      const now = performance.now ? performance.now() : Date.now();
      const dx = x - lastGYQuery.x, dz = z - lastGYQuery.z;
      if(Math.hypot(dx, dz) < 1.5 && (now - lastGYQuery.time) < 10){
        return lastGYQuery.y;
      }
      sharedRaycaster.ray.origin.set(x, 1000, z);
      sharedRaycaster.ray.direction.set(0, -1, 0);
      sharedRaycaster.near = 0; sharedRaycaster.far = 2000;
      const hits = sharedRaycaster.intersectObject(externalMapRoot, true);
      if(hits && hits.length){
        lastGYQuery = { x, z, y: hits[0].point.y, time: now };
        return hits[0].point.y;
      }
      lastGYQuery = { x, z, y: 0, time: now };
      return 0; // ヒットしない場合は地面0
    }
    let gy = 0;
    if(landmarkInfo){
      const dx = x - landmarkInfo.x, dz = z - landmarkInfo.z;
      const r = Math.hypot(dx, dz);
      const rr = (landmarkInfo.roofRadius || 12);
      if(r < rr){ gy = Math.max(gy, landmarkInfo.height); }
    }
    return gy;
  }

  function createCompositeTower(x, z, heightBias=1.0){
    const group = new Group();
    group.position.set(x, 0, z);
    towerGroup.add(group);

    const baseW = (12 + Math.random()*18) * (0.75 + heightBias*0.4);
    const baseD = (12 + Math.random()*18) * (0.75 + heightBias*0.4);
    const podiumH = 6 + Math.random()*10;
    const podium = new Mesh(unitBox, cloneMatWithJitter(podiumTemplate, (Math.random()*0.1)-0.05));
    podium.scale.set(baseW, podiumH, baseD);
    podium.position.y = podiumH*0.5;
    group.add(podium);

    let currentY = podiumH;
    let width = baseW * (0.82 + Math.random()*0.12);
    let depth = baseD * (0.82 + Math.random()*0.12);
    const segmentCount = 3 + Math.floor(Math.random()*2);
    const anchors = [];
    let totalHeight = currentY;
    const facadeTemplate = (Math.random()<0.55 ? towerTemplateWarm : towerTemplateCool);
    for(let s=0; s<segmentCount; s++){
      const heightMul = 0.65 + heightBias*0.45;
      const segH = (18 + Math.random()*16) * heightMul * (1 - s*0.08);
      const segment = new Mesh(unitBox, cloneMatWithJitter(facadeTemplate, (Math.random()*0.06)-0.03));
      segment.scale.set(width, segH, depth);
      segment.position.y = currentY + segH*0.5;
      group.add(segment);
      const anchorTop = segment.position.y + segH*0.25;
      if(anchorTop > 12) anchors.push(anchorTop);
      currentY += segH;
      totalHeight = currentY;
      width *= 0.78 + Math.random()*0.14;
      depth *= 0.78 + Math.random()*0.14;
    }

    const capH = (12 + Math.random()*18) * (0.5 + heightBias*0.4);
    const cap = new Mesh(unitBox, cloneMatWithJitter(capTemplate, (Math.random()*0.08)-0.04));
    cap.scale.set(width*0.92, capH, depth*0.92);
    cap.position.y = currentY + capH*0.5;
    group.add(cap);
    let topY = cap.position.y + capH*0.5;
    anchors.push(cap.position.y + capH*0.3);

    if(Math.random()<0.75){
      const spireH = 8 + Math.random()*20;
      const spire = new Mesh(spireGeo, cloneMatWithJitter(spireTemplate, (Math.random()*0.06)-0.03));
      spire.scale.set(1 + Math.random()*0.6, spireH, 1 + Math.random()*0.6);
      spire.position.y = cap.position.y + capH*0.5 + spireH*0.5;
      group.add(spire);
      topY = spire.position.y + spireH*0.5;
      anchors.push(spire.position.y - spireH*0.35);
    }

    const totalRadius = Math.max(baseW, baseD) * 0.58;
    const totalHeightRef = topY;
    const stripCount = 2 + Math.floor(Math.random()*3);
    for(let n=0;n<stripCount;n++){
      const stripMat = neonStripBase.clone();
      stripMat.color = new Color(neonPalette[Math.floor(Math.random()*neonPalette.length)]);
      stripMat.opacity = 0.7 + Math.random()*0.25;
      const strip = new Mesh(stripGeo, stripMat);
      strip.scale.set(Math.max(0.8, baseW*0.14), totalHeightRef*0.92, 1);
      strip.position.y = totalHeightRef*0.5;
      const face = Math.floor(Math.random()*4);
      switch(face){
        case 0: strip.position.z = depth*0.5 + 0.14; break;
        case 1: strip.position.z = -depth*0.5 - 0.14; break;
        case 2: strip.position.x = width*0.5 + 0.14; strip.rotation.y = Math.PI/2; break;
        default: strip.position.x = -width*0.5 - 0.14; strip.rotation.y = Math.PI/2; break;
      }
      group.add(strip);
    }

    anchors.sort((a,b)=>a-b);
    const anchorHeights = anchors.filter((_,idx)=>idx >= anchors.length-3);

    const info = { group, x, z, radius: totalRadius, height: totalHeightRef, anchors: anchorHeights };
    cityTowers.push(info);
    return info;
  }

  function canPlaceTower(x, z, minDist){
    for(let i=0;i<cityTowers.length;i++){
      const t = cityTowers[i];
  // 中央ランドマーク周辺は少し広めに空けておく
  const effectiveMin = (landmarkInfo && t === landmarkInfo) ? (minDist + 20) : minDist;
      const dx = t.x - x; const dz = t.z - z;
  if(dx*dx + dz*dz < effectiveMin*effectiveMin) return false;
    }
    return true;
  }

  function spawnTowerCluster(cx, cz, radius, count, bias){
    for(let i=0;i<count;i++){
      let placed = false;
      for(let attempt=0; attempt<8 && !placed; attempt++){
        const ang = Math.random()*Math.PI*2;
        const r = Math.sqrt(Math.random()) * radius;
        const x = cx + Math.cos(ang)*r + (Math.random()*24 - 12);
        const z = cz + Math.sin(ang)*r + (Math.random()*24 - 12);
        if(Math.abs(x) > 480 || Math.abs(z) > 480) continue;
        if(!canPlaceTower(x, z, 28)) continue;
        createCompositeTower(x, z, bias);
        placed = true;
      }
    }
  }

  // まず中心ランドマークを生成（他タワーは距離制約で回避）
  if(!useExternalMap){
    landmarkInfo = createLandmarkMegaTower(0, 0);
    // 屋上へ初期スポーン（目線高を加味してその場で立てるように）
    if(landmarkInfo){
      camera.position.set(landmarkInfo.x, landmarkInfo.height + 1.6, landmarkInfo.z + 2);
    }
  }
  // 屋上の床とエレベーター乗り場を構築
  // 屋上の床とエレベーター乗り場（関数定義のみ：実行はコリジョン準備後）
  const buildRooftopForLandmark = (info)=>{
      // 屋上が広くなりすぎないよう、デッキサイズ係数を少し下げる
      const deckSize = Math.max(10, (info.roofRadius||20) * 2 * 0.78);
      // 床タイル
      const tileTex = makeTileTexture();
      tileTex.repeat.set(deckSize/2, deckSize/2); // 2mピッチ相当
      const deckMat = new MeshStandardMaterial({ color:0xffffff, map: tileTex, roughness:0.92, metalness:0.08 });
      const deck = new Mesh(new PlaneGeometry(deckSize, deckSize), deckMat);
      deck.rotation.x = -Math.PI/2; deck.position.set(info.x, info.height + 0.03, info.z); deck.receiveShadow = true; scene.add(deck);
  // 物理エンジン用: 屋上デッキを薄いBoxとして追加（プレイヤーが上に乗れるように）
  const deckHalfX = deckSize * 0.5;
  const deckHalfZ = deckSize * 0.5;
  const deckHalfY = 0.1; // デッキ厚み
  const rooftopShape = new CANNON.Box(new CANNON.Vec3(deckHalfX, deckHalfY, deckHalfZ));
  const rooftopBody = new CANNON.Body({ mass: 0, shape: rooftopShape });
  rooftopBody.position.set(info.x, info.height, info.z);
  world.addBody(rooftopBody);
  // エレベーターヘッドハウス（少し小さめに）
  const hutW = 6, hutD = 4.5, hutH = 8;
      const hutMat = new MeshStandardMaterial({ color:0x1b212a, roughness:0.65, metalness:0.45, emissive:0x142238, emissiveIntensity:0.2 });
      const hut = new Mesh(new BoxGeometry(hutW, hutH, hutD), hutMat);
      hut.castShadow=true; hut.receiveShadow=true;
      const margin = 4; // 屋上端からの余白
      const hx = info.x + (deckSize*0.5 - hutW*0.5 - margin);
      const hz = info.z - (deckSize*0.5 - hutD*0.5 - margin);
      hut.position.set(hx, info.height + hutH*0.5, hz); scene.add(hut);
      // ドアパネル（発光）
      const doorW=3.6, doorH=6.5;
      const doorMat = new MeshStandardMaterial({ color:0x0b0e13, emissive:0x66e0ff, emissiveIntensity:0.35, roughness:0.8, metalness:0.2 });
      const door = new Mesh(new PlaneGeometry(doorW, doorH), doorMat);
      door.position.set(hx, info.height + 2.2 + doorH*0.5, hz + hutD*0.51); // 南面（手前）
      scene.add(door);
      // 乗り場前の通路（ハザードストライプ）
      const hazTex = makeHazardTexture(); hazTex.repeat.set(1.5,0.7);
      const walkMat = new MeshStandardMaterial({ map: hazTex, roughness:0.95, metalness:0.05 });
      const walkway = new Mesh(new PlaneGeometry(6.0, 4.0), walkMat);
      walkway.rotation.x = -Math.PI/2; walkway.position.set(hx, info.height + 0.035, hz + hutD*0.5 + 2.0); walkway.receiveShadow=true; scene.add(walkway);
      // コールパネル（小型発光ボックス）
      const panel = new Mesh(new BoxGeometry(0.24, 0.6, 0.12), new MeshStandardMaterial({ color:0x111, emissive:0x99ddff, emissiveIntensity:0.6, roughness:0.7 }));
      panel.position.set(hx + doorW*0.5 + 0.4, door.position.y - doorH*0.2, hz + hutD*0.52); scene.add(panel);
      // 乗り場ライト
      const lamp = new PointLight(0x66aaff, 2.2, 22, 1.6); lamp.castShadow=false; lamp.position.set(hx, door.position.y + 1.2, hz + hutD*0.6); scene.add(lamp);
      // 頭上ライトバー（加算）
      const bar = new Mesh(new BoxGeometry(3.8,0.12,0.1), new MeshBasicMaterial({ color:0x77ccff, transparent:true, opacity:0.8, blending:THREE.AdditiveBlending }));
      bar.position.set(hx, door.position.y + doorH*0.55, hz + hutD*0.55); scene.add(bar);
  // 簡易コリジョン（ヘッドハウス）
  // 見た目に沿うよう、矩形ボックスで当たり判定を付ける（少し内側にオフセット）
  const halfX = hutW*0.5 * 0.9;
  const halfZ = hutD*0.5 * 0.9;
  addBoxCollider(hx, hz, halfX, halfZ, 0);
  };
  if(!useExternalMap){
    spawnTowerCluster(0, 0, 190, 46, 1.25);
    spawnTowerCluster(210, 90, 150, 26, 1.05);
    spawnTowerCluster(-220, 110, 150, 26, 1.1);
    spawnTowerCluster(170, -210, 140, 24, 0.95);
    spawnTowerCluster(-230, -170, 150, 24, 0.95);
    spawnTowerCluster(0, 240, 130, 18, 0.85);
    spawnTowerCluster(0, -240, 130, 18, 0.85);
  }

  function chooseBridgeAnchor(a, b){
    let best = null; let bestDiff = Infinity;
    for(let i=0;i<a.anchors.length;i++){
      for(let j=0;j<b.anchors.length;j++){
        const diff = Math.abs(a.anchors[i] - b.anchors[j]);
        if(diff < bestDiff){
          bestDiff = diff;
          best = { height: (a.anchors[i] + b.anchors[j]) * 0.5 };
        }
      }
    }
    return (best && bestDiff < 14) ? best : null;
  }

  const bridgeDeckMat = new MeshStandardMaterial({ color: 0x1b2836, emissive: 0x12324e, emissiveIntensity: 0.48, roughness: 0.55, metalness: 0.6 });
  const bridgeConnectionCounts = new Array(cityTowers.length).fill(0);
  const bridgeDir = new Vector3();
  const bridgeMid = new Vector3();

  for(let i=0;i<cityTowers.length;i++){
    for(let j=i+1;j<cityTowers.length;j++){
      if(bridgeConnectionCounts[i] >= 3 || bridgeConnectionCounts[j] >= 3) continue;
      const a = cityTowers[i]; const b = cityTowers[j];
  const dx = b.x - a.x; const dz = b.z - a.z;
  const dist = Math.sqrt(dx*dx + dz*dz);
  // 中央ランドマークを跨ぐような短い橋は作らないよう、最短距離を少し長めに設定
  if(dist < 48 || dist > 170) continue;
      if(Math.random() > 0.55) continue;
      const anchor = chooseBridgeAnchor(a, b);
      if(!anchor) continue;
      const length = dist - (a.radius + b.radius) * 0.65;
      if(length <= 6) continue;
      const width = 4.2 + Math.random()*1.8;
      bridgeMid.set((a.x + b.x)*0.5, anchor.height, (a.z + b.z)*0.5);
      const walkway = new Group();
      walkway.position.copy(bridgeMid);
      bridgeDir.set(dx, 0, dz).normalize();
      const quat = new THREE.Quaternion().setFromUnitVectors(new Vector3(0,0,1), bridgeDir);
      walkway.setRotationFromQuaternion(quat);
      const deck = new Mesh(unitBox, cloneMatWithJitter(bridgeDeckMat, (Math.random()*0.04)-0.02));
      deck.scale.set(width, 1.1, length);
      walkway.add(deck);
      const railColor = neonPalette[Math.floor(Math.random()*neonPalette.length)];
      for(const side of [-1, 1]){
        const railMat = new MeshBasicMaterial({ color: railColor, transparent: true, opacity: 0.75, depthWrite: false, blending: THREE.AdditiveBlending });
        const rail = new Mesh(unitBox, railMat);
        rail.scale.set(length, 0.25, 0.18);
        rail.position.set(0, 0.8, side*(width*0.5 + 0.1));
        walkway.add(rail);
      }
      bridgeGroup.add(walkway);
      skybridges.push({ ax: a.x, az: a.z, bx: b.x, bz: b.z, height: anchor.height });
      bridgeConnectionCounts[i]++; bridgeConnectionCounts[j]++;
    }
  }

  // --- neon signs with intermittent flicker and sparks
let neonGroup; if(!useExternalMap){ neonGroup = new Group(); scene.add(neonGroup); }
const neonMeshes = []; const neonCtrl = [];
function addNeon(x, z, w=3.2, h=1.0, color=0x66e0ff){
  const geo = new PlaneGeometry(w, h);
  const mat = new MeshStandardMaterial({ color: 0x060606, emissive: color, emissiveIntensity: 0.4, roughness: 0.82, metalness: 0.15 });
  const m = new Mesh(geo, mat); m.rotation.x = -Math.PI/2; m.rotation.z = Math.random()*Math.PI;
  m.position.set(x, 0.03, z); m.rotation.x = -Math.PI/2 + (Math.random()*2-1)*0.15;
  if(!useExternalMap){ neonGroup.add(m); }
  neonMeshes.push(m);
  if(!useExternalMap){
    const light = new PointLight(color, 0.0, 12, 2.0); light.position.set(x, 1.0, z); scene.add(light);
    neonCtrl.push({ base: 2.2 + Math.random()*3.0, speed: 2.0 + Math.random()*3.0, jitter: Math.random()*Math.PI*2, offProb: 0.04 + Math.random()*0.05, nextSpark: 0, light });
  } else {
    neonCtrl.push({ base: 0, speed: 0, jitter: 0, offProb: 1, nextSpark: 0, light: null });
  }
}
// distribute some neons near roads
if(!useExternalMap){
  const neonColors = neonPalette;
  for(let i=0;i<12;i++){
    const onX = Math.random()<0.5;
    const col = neonColors[Math.floor(Math.random()*neonColors.length)];
    if(onX){ addNeon((Math.random()*2-1)*480, (Math.random()<0.5? 9.0 : -9.0) + (Math.random()*2-1)*3, 3+Math.random()*2, 0.8+Math.random()*0.6, col); }
    else { addNeon((Math.random()<0.5? 9.0 : -9.0) + (Math.random()*2-1)*3, (Math.random()*2-1)*480, 3+Math.random()*2, 0.8+Math.random()*0.6, col); }
  }
}

// spark particle system
const sparkBursts = [];
function spawnSparkParticles(pos){
  if(useExternalMap) return;
  const count = 20;
  const g = new BufferGeometry();
  const positions = new Float32Array(count*3);
  const velocities = new Float32Array(count*3);
  for(let i=0;i<count;i++){
    const ix = i*3;
    positions[ix+0] = pos.x; positions[ix+1] = pos.y + 0.1; positions[ix+2] = pos.z;
    const a = Math.random()*Math.PI*2; const up = Math.random()*0.9 + 0.2;
    const sp = 3.0 + Math.random()*4.0;
    velocities[ix+0] = Math.cos(a)*sp*0.5; velocities[ix+1] = up*sp; velocities[ix+2] = Math.sin(a)*sp*0.5;
  }
  g.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
  g.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));
  const m = new PointsMaterial({ color: 0xfff2a8, size: 0.08, transparent: true, opacity: 1.0, depthWrite:false });
  const p = new Points(g, m); p.userData.life = 0.25 + Math.random()*0.25; p.userData.age = 0;
  scene.add(p); sparkBursts.push(p);
}

// --- wrecked cars (low-poly)
let carGroup; if(!useExternalMap){ carGroup = new Group(); scene.add(carGroup); }
// shared geometries/materials
const gCarBody = new BoxGeometry(3.6, 1.2, 1.6); gCarBody.translate(0, 0.6, 0);
const gCarCab = new BoxGeometry(2.0, 0.9, 1.5); gCarCab.translate(-0.2, 1.35, 0);
const gWheel = new CylinderGeometry(0.36, 0.36, 0.4, 16); gWheel.rotateZ(Math.PI/2);
const matMetal = new MeshStandardMaterial({ color: 0x4a4d50, roughness: 0.9, metalness: 0.2 });
const matPaints = [0x5a6a77,0x7a3b3b,0x3d5a3d,0x6a5a3d,0x3a3f6a].map(c=>new MeshStandardMaterial({ color:c, roughness:0.85, metalness:0.3 }));
const matGlass = new MeshStandardMaterial({ color: 0x88a0b5, roughness: 0.2, metalness: 0.0, transparent:true, opacity:0.5 });
const matTire = new MeshStandardMaterial({ color: 0x1a1a1a, roughness: 1.0, metalness: 0.0 });
function makeCar(){
  const g = new Group();
  const body = new Mesh(gCarBody, matPaints[Math.floor(Math.random()*matPaints.length)]);
  const cab = new Mesh(gCarCab, matGlass);
  const wheelPositions = [
    [ 1.3, 0.36,  0.8], [ 1.3, 0.36, -0.8],
    [-1.3, 0.36,  0.8], [-1.3, 0.36, -0.8]
  ];
  const wheels = wheelPositions.map(p=>{ const w=new Mesh(gWheel, matTire); w.position.set(p[0],p[1],p[2]); return w; });
  // damage: chance to miss a wheel or tilt
  wheels.forEach((w,idx)=>{ if(Math.random()<0.18){ w.scale.set(0.001,0.001,0.001); w.visible=false; } });
  g.add(body, cab, ...wheels);
  // slight dents by random rotations and scales
  g.rotation.y = (Math.random()*2-1)*Math.PI;
  g.rotation.z = (Math.random()*2-1)*0.06;
  g.position.y = 0.02;
  const s = 0.95 + Math.random()*0.15; g.scale.set(s,s,s);
  return g;
}
function spawnCarsAlongRoads(count=28){
  if(useExternalMap) return;
  let c=0;
  while(c<count){
    const onX = Math.random()<0.5;
    const pos = new Vector3();
    if(onX){
      pos.x = (Math.random()*2-1)*1200; pos.z = (Math.random()<0.5? 3.6 : -3.6) + (Math.random()*2-1)*1.2;
    } else {
      pos.z = (Math.random()*2-1)*1200; pos.x = (Math.random()<0.5? 3.6 : -3.6) + (Math.random()*2-1)*1.2;
    }
    const car = makeCar(); car.position.add(pos);
    // chance to be heavily wrecked (on side)
    if(Math.random()<0.2){ car.rotation.x = (Math.random()*2-1)*0.9; car.rotation.z = (Math.random()*2-1)*0.6; }
carGroup.add(car);
  // 物理エンジン用Box剛体（横倒しの車もあるので、Y方向の中心は地面付近に）
  const halfLen = 3.6*0.5 * 0.9;
  const halfWid = 1.6*0.5 * 0.9;
  const halfH   = 0.8; // おおよその車高半分
  const center = new THREE.Vector3(car.position.x, halfH, car.position.z);
  addStaticBoxBody(center, halfLen, halfH, halfWid, car.rotation.y||0);
  c++;
  }
}
if(!useExternalMap){ spawnCarsAlongRoads(30); }

// --- fallen/tilted billboards
let signGroup; if(!useExternalMap){ signGroup = new Group(); scene.add(signGroup); }
function spawnBillboards(n=12){
  if(useExternalMap) return;
  for(let i=0;i<n;i++){
    const onX = Math.random()<0.5; const b = makeBillboard();
  if(onX){ b.position.x = (Math.random()*2-1)*480; b.position.z = (Math.random()<0.5? 10.5 : -10.5) + (Math.random()*2-1)*4; }
  else { b.position.z = (Math.random()*2-1)*480; b.position.x = (Math.random()<0.5? 10.5 : -10.5) + (Math.random()*2-1)*4; }
    b.rotation.y = Math.random()*Math.PI;
  signGroup.add(b);
  // 看板全体の占有領域を薄いBoxで近似
  const halfX = 3.0;   // 横方向
  const halfZ = 0.6;   // 薄さ
  const halfY = 2.6;   // 高さ半分
  const centerY = b.position.y + 2.6; // おおよそ地面からの高さ
  const center = new THREE.Vector3(b.position.x, centerY, b.position.z);
  addStaticBoxBody(center, halfX, halfY, halfZ, b.rotation.y||0);
  }
}
if(!useExternalMap){ spawnBillboards(14); }

// skyline ring
if(!useExternalMap){
  const skylineInst = new InstancedMesh(skyGeo, skyMat, skylineCount); scene.add(skylineInst);
  const skyDummy = new THREE.Object3D();
  const ringR1 = 560, ringR2 = 880; let si=0;
  for(let k=0;k<skylineCount;k++){
    const ang = (k/skylineCount)*Math.PI*2 + Math.random()*0.06;
    const r = ringR1 + Math.random()*(ringR2-ringR1);
    const x = Math.cos(ang)*r; const z = Math.sin(ang)*r;
    const w = 8 + Math.random()*20; const d = 8 + Math.random()*20; const h = 60 + Math.random()*180;
    skyDummy.position.set(x, h*0.5, z);
    skyDummy.scale.set(w, h, d);
    skyDummy.rotation.y = -ang + (Math.random()*2-1)*0.2; // roughly face toward center
    skyDummy.updateMatrix(); skylineInst.setMatrixAt(si++, skyDummy.matrix);
  }
  skylineInst.count = si; skylineInst.instanceMatrix.needsUpdate = true;
}

// fog sheets
const fogSheets = []; let fogGroup; if(!useExternalMap){ fogGroup = new Group(); scene.add(fogGroup); }
function addFogSheet(x,z,w=420,h=120,rot=0){
  if(useExternalMap) return;
  const geo=new PlaneGeometry(w,h); const mat=new MeshBasicMaterial({ map:fogTex, transparent:true, opacity:0.8, depthWrite:false, blending:THREE.AdditiveBlending, side:DoubleSide });
  const m=new Mesh(geo,mat); m.position.set(x, h*0.5*0.2 + 0.6, z); m.rotation.y = rot; // stand vertical
  fogGroup.add(m); fogSheets.push({ m, dir:(Math.random()*2-1)*0.2 });
}
if(!useExternalMap){
  for(let i=0;i<8;i++){
    const onX = Math.random()<0.5;
    if(onX) addFogSheet((Math.random()*2-1)*380, (Math.random()<0.5?-1:1)*60 + (Math.random()*2-1)*120, 420+Math.random()*200, 120+Math.random()*80, Math.random()*0.3-0.15);
    else addFogSheet((Math.random()<0.5?-1:1)*60 + (Math.random()*2-1)*120, (Math.random()*2-1)*380, 420+Math.random()*200, 120+Math.random()*80, Math.random()*0.3-0.15);
  }
}

// dust particles
const dustGeo = new BufferGeometry();
const dustCount = 800;
const posArr = new Float32Array(dustCount*3);
// ダスト粒子の広がり範囲（地形縮小に合わせて調整）
const baseXZ = 140, baseY = 0.6;
for(let i=0;i<dustCount;i++){
  posArr[i*3+0] = (Math.random()*2-1)*baseXZ;
  posArr[i*3+1] = baseY + Math.random()*2.5;
  posArr[i*3+2] = (Math.random()*2-1)*baseXZ;
}
dustGeo.setAttribute('position', new THREE.Float32BufferAttribute(posArr, 3));
const dustMat = new PointsMaterial({ color: 0xb7bdc3, size: 0.18, sizeAttenuation: true, transparent: true, opacity: 0.25, depthWrite: false });
const dustPoints = new Points(dustGeo, dustMat); if(!useExternalMap){ scene.add(dustPoints); }

// enemies
let enemyGroup; if(!useExternalMap){ enemyGroup = new Group(); scene.add(enemyGroup); }
function spawnEnemies(n=6){
  if(useExternalMap) return;
  for(let i=0;i<n;i++){
    const ang = Math.random()*Math.PI*2; const dist = 30 + Math.random()*60; // 縮小マップに合わせスポーン距離短縮
      const ex = camera.position.x + Math.cos(ang)*dist;
      const ez = camera.position.z + Math.sin(ang)*dist;
      enemies.push(createShadowEnemy(ex, ez));
  }
}
if(!useExternalMap){ spawnEnemies(7); }

// updates: guard when external map
// neon flicker & sparks
if(useExternalMap){
  // skip neon updates, spark simulation, dust drift, enemy AI when using external map
  // Place concise guards inside respective update loops
}

// --- Debug: collider visualization ---
  const debugGroup = new Group(); scene.add(debugGroup);
  let showColliders = false;
  function setShowColliders(v){ showColliders = !!v; debugGroup.visible = showColliders; }
  setShowColliders(false);

  // player movement (pointer lock FPS)
  let pitch = 0, yaw = 0;
  // ポーズ管理（オーバーレイ表示中はゲーム停止&カーソル復活）
  let isPaused = false;
  function pauseGame(){
    isPaused = true;
    if(document.pointerLockElement === document.body){
      document.exitPointerLock();
    }
  }
  function resumeGame(){
    isPaused = false;
    document.body.requestPointerLock();
  }
  const velocity = new Vector3(0,0,0);
  const move = { forward:false, back:false, left:false, right:false };
  const speed = 8.0;
  const hVel = new Vector3(0,0,0);
  const accel = 40.0, deccel = 30.0;
  const jumpSpeed = 15.5;
  // 連続ジャンプ防止用のクールダウン
  let jumpCooldown = 0.0;
  const jumpCooldownDur = 0.2; // 秒
  let dashTime = 0; const dashDuration = 0.18; let dashCooldown = 0; const dashCooldownDur = 0.8; const dashMultiplier = 1.0; // 新ダッシュ=旧歩行
  let stamina = 100.0; const staminaMax = 100.0; const staminaUseRate = 6.0; const staminaRegenRate = 18.0; let health = 100.0; const healthMax=100.0; let dashHeld=false;
  // スタミナ枯渇時の鈍足・ダッシュ不可状態
  let exhausted = false; const slowMultiplier = 0.5;

  // --- チェックポイントと落下ダメージ ---
  // 初期スポーン位置をチェックポイントとして保持
  const checkpoint = {
    x: camera.position.x,
    y: camera.position.y,
    z: camera.position.z,
  };
  // 落下ダメージ計算用（距離ベース）
  let lastVelY = 0;                // 前フレームの縦速度（演出用に保持）
  let fallStartY = null;           // 落下開始時の高さ（playerBody.position.y ベース）
  const lethalFallHeight = 20.0;   // 20m 以上の落下で即死
  const stunFallHeight   = 4.0;    // 4m 以上の落下で一瞬膠着
  const fallDamageScale  = 3.0;    // 致死未満の落下に対するダメージスケール
  let isDead = false;

  function applyDamage(amount){
    health = Math.max(0, health - amount);
    // UI 側のバー更新は後段の updateHealthUI で行われる
  }

  function reviveAtCheckpoint(){
    // HP/スタミナ全回復し、プレイヤーをチェックポイントへ戻す
    health = healthMax;
    stamina = staminaMax;
    exhausted = false;
  player.grounded = false;
    // player.node は足元座標なので、カメラ位置から eyeOffset を引いてセット
    player.node.position.set(
      checkpoint.x,
      checkpoint.y - player.eyeOffset,
      checkpoint.z
    );
    camera.position.set(checkpoint.x, checkpoint.y, checkpoint.z);
    isDead = false;
    // ポインタロックを解除し、『クリックして開始』オーバーレイを再び表示
    if(document.pointerLockElement === document.body){
      document.exitPointerLock();
    }
    if(overlay){ overlay.style.display = 'block'; }
    gameStarted = false;
  }

  // --- 死亡演出用 UI と三人称カメラ ---
  let deathCameraOffset = new THREE.Vector3(0, 6, 10);
  let deathFocusPos = new THREE.Vector3();
  let deathOverlayVisible = false;

  const deathOverlay = document.createElement('div');
  Object.assign(deathOverlay.style, {
    position:'fixed', inset:'0', display:'none', alignItems:'center', justifyContent:'center',
    background:'rgba(0,0,0,0.7)', zIndex:10000, color:'#fff'
  });
  const deathPanel = document.createElement('div');
  Object.assign(deathPanel.style, {
    background:'rgba(20,22,26,0.95)', padding:'16px 20px', borderRadius:'10px',
    minWidth:'280px', textAlign:'center', boxShadow:'0 8px 24px rgba(0,0,0,0.6)'
  });
  deathPanel.innerHTML = `
    <div style="font-size:20px;font-weight:800;margin-bottom:12px">死亡しました</div>
    <div style="font-size:13px;opacity:0.85;margin-bottom:16px">タイトルに戻るか、チェックポイントから再開します。</div>
    <div style="display:flex;flex-direction:column;gap:8px">
      <button id="btn-respawn" style="padding:8px 10px;border-radius:6px;border:0;background:#3b7cff;color:#fff;font-weight:600;cursor:pointer">チェックポイントから再開</button>
      <button id="btn-title" style="padding:8px 10px;border-radius:6px;border:0;background:#555;color:#fff;cursor:pointer">タイトルに戻る</button>
    </div>
  `;
  deathOverlay.appendChild(deathPanel);
  document.body.appendChild(deathOverlay);

  const btnRespawn = deathPanel.querySelector('#btn-respawn');
  const btnTitle = deathPanel.querySelector('#btn-title');

  function showDeathOverlay(){
    deathOverlayVisible = true;
    deathOverlay.style.display = 'flex';
    // ポインタロックが掛かっている場合は解除してマウス操作を可能にする
    if(document.pointerLockElement === document.body){
      document.exitPointerLock();
    }
  }

  function hideDeathOverlay(){
    deathOverlayVisible = false;
    deathOverlay.style.display = 'none';
  }

  if(btnRespawn){
    btnRespawn.addEventListener('click', ()=>{
      hideDeathOverlay();
      reviveAtCheckpoint();
    });
  }
  if(btnTitle){
    btnTitle.addEventListener('click', ()=>{
  // 別HTMLへ遷移せず、この index(1).html 内のタイトル状態へ戻す
  hideDeathOverlay();
  // プレイヤーをチェックポイントに戻しつつ、再度タイトル画面からやり直せるようにする
  reviveAtCheckpoint();
  showTitle();
    });
  }

  function onMouseMove(e){
    if(document.pointerLockElement !== document.body) return;
    const movementX = e.movementX || 0; const movementY = e.movementY || 0;
    yaw -= movementX * 0.002; pitch -= movementY * 0.002;
    pitch = Math.max(-Math.PI/2+0.01, Math.min(Math.PI/2-0.01, pitch));
    camera.quaternion.setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));
  }
  function onKey(e, down){
    const k = e.key.toLowerCase();
  if(k==='w') move.forward = down; if(k==='s') move.back = down; if(k==='a') move.left = down; if(k==='d') move.right = down;
  if(k==='m' && down){ toggleMap(); if(mapVisible) drawMap(); }
  if(k==='o' && down){ toggleSettings(); }
  if(k==='i' && down){ toggleInventory(); }
  if(k==='e' && down){ tryInteract(); }
  if(k==='r' && down){ tryUseBattery(); }
  if(k==='h' && down){ setShowColliders(!showColliders); }
    // Shift の押下/解放を常に反映（keyupでも反映されるように）
    if(e.code === 'ShiftLeft' || e.code === 'ShiftRight' || e.key === 'Shift'){
      dashHeld = down;
      // ダッシュの瞬間ブーストは keydown のみで発火（疲労状態は不可）
      if(down && !exhausted && dashCooldown<=0 && dashTime<=0 && stamina>5){ dashTime=dashDuration; dashCooldown=dashCooldownDur; }
    }
    if(down){
      if(e.code === 'Space' || k===' ' || k==='spacebar'){
        // 接地かつ垂直速度がほぼゼロ、かつジャンプクールダウン無しのときのみジャンプ
        const canJump = player.grounded && Math.abs(playerBody.velocity.y) < 0.05 && jumpCooldown<=0;
        if(canJump){
          // 物理ボディにジャンプ速度を与える
          playerBody.velocity.y = jumpSpeed;
          player.grounded = false;
          jumpCooldown = jumpCooldownDur;
        }
      }
    }
  }
  window.addEventListener('mousemove', onMouseMove);
  window.addEventListener('keydown', (e)=>onKey(e,true));
  window.addEventListener('keyup', (e)=>onKey(e,false));
  window.addEventListener('resize', sizeMapCanvas);
  // 安全策: フォーカス喪失や可視状態変化、PointerLock解除時にダッシュ状態を解除
  window.addEventListener('blur', ()=>{ dashHeld = false; });
  document.addEventListener('visibilitychange', ()=>{ if(document.hidden){ dashHeld = false; } });
  document.addEventListener('pointerlockchange', ()=>{ if(document.pointerLockElement !== document.body){ dashHeld = false; } });
  // Battery UI helpers
  function updateBatteryUI(){
    const cells = [document.getElementById('bat-cell-1'),document.getElementById('bat-cell-2'),document.getElementById('bat-cell-3')];
    for(let i=0;i<cells.length;i++){
      const filled = (i < batterySegments);
      const el = cells[i]; if(!el) continue;
      el.style.opacity = filled? '1' : '0.18';
      el.style.background = filled? '#2ecc71' : '#666';
    }
  }

  // ---------- Interactables & Inventory ----------
  const interactRay = new THREE.Raycaster();
  interactRay.far = 3.0; // interact distance ~3m
  // uses global interactables defined earlier
  let highlighted = null; let highlightedPrevMat = null; let highlightedScale = 1;
  // UI: crosshair + prompt
  const crosshair = document.createElement('div');
  Object.assign(crosshair.style, { position:'fixed', left:'50%', top:'50%', width:'6px', height:'6px', transform:'translate(-50%,-50%)', borderRadius:'50%', background:'rgba(255,255,255,0.9)', boxShadow:'0 0 8px rgba(255,255,255,0.6)', zIndex:9998, pointerEvents:'none' });
  document.body.appendChild(crosshair);
  const prompt = document.createElement('div');
  Object.assign(prompt.style, { position:'fixed', left:'50%', top:'calc(50% + 18px)', transform:'translateX(-50%)', color:'#fff', background:'rgba(0,0,0,0.55)', padding:'4px 8px', borderRadius:'6px', fontSize:'13px', zIndex:9998, pointerEvents:'none', display:'none' });
  document.body.appendChild(prompt);
  // 脱出ゲート（シェルター）
  const gateGeo = new THREE.BoxGeometry(1.8, 2.2, 0.2);
  const gateMat = new THREE.MeshStandardMaterial({ color: 0x8899aa, emissive: 0x000000, roughness: 0.7, metalness: 0.2 });
  const gate = new THREE.Mesh(gateGeo, gateMat); gate.castShadow = true; gate.receiveShadow = true;
  gate.position.set(-2.5, 1.1, -12.0);
  gate.userData = { interactable: 'gate', name: '非常用シェルター扉' };
  scene.add(gate);
  interactables.push(gate);
  function canActivateGate(){ return countRequiredCollected() >= 3; }
  // Progress HUD: 起動モジュール進捗
  const progressHUD = document.createElement('div');
  Object.assign(progressHUD.style, { position:'fixed', right:'12px', top:'12px', background:'rgba(0,0,0,0.55)', color:'#fff', padding:'8px 10px', borderRadius:'8px', fontSize:'13px', zIndex:9998 });
  progressHUD.id = 'progress-hud';
  progressHUD.textContent = '起動モジュール: 0/3';
  document.body.appendChild(progressHUD);

  const REQUIRED_ITEMS = [
    { kind:'battery_cell', name:'電源セル' },
    { kind:'access_key',  name:'アクセスキー' },
    { kind:'boot_chip',   name:'起動チップ' },
  ];
  function countRequiredCollected(){
    let cnt = 0;
    for(const req of REQUIRED_ITEMS){
      // スロット配列対応（inventory は固定スロット配列）
      for(let i=0;i<inventory.length;i++){
        const it = inventory[i];
        if(it && it.kind===req.kind && it.qty>0){ cnt++; break; }
      }
    }
    return cnt;
  }
  function updateProgressHUD(){
    const c = countRequiredCollected();
    const hud = document.getElementById('progress-hud');
    if(hud) hud.textContent = `起動モジュール: ${c}/3`;
  }
  // Inventory overlay（グリッド枠 + スタック最大64）
  let inventoryVisible = false;
  const INVENTORY_SLOTS = 12; // 3x4 グリッド
  const STACK_MAX = 64;
  const inventory = new Array(INVENTORY_SLOTS).fill(null);
  const invOverlay = document.createElement('div'); invOverlay.id = 'inventory-overlay';
  Object.assign(invOverlay.style, { position:'fixed', inset:'0', display:'none', alignItems:'center', justifyContent:'center', background:'rgba(0,0,0,0.55)', zIndex:9999 });
  const invPanel = document.createElement('div');
  Object.assign(invPanel.style, { background:'rgba(20,22,26,0.95)', color:'#fff', padding:'12px 14px', borderRadius:'8px', minWidth:'300px', maxWidth:'80vw', maxHeight:'70vh', overflow:'auto', boxShadow:'0 8px 24px rgba(0,0,0,0.6)' });
  invPanel.innerHTML = '<div style="font-weight:700;margin-bottom:8px">インベントリ (Iで閉じる)</div><div id="inv-list" style="display:grid;grid-template-columns:repeat(4,64px);gap:10px;justify-content:center"></div>';
  invOverlay.appendChild(invPanel); document.body.appendChild(invOverlay);
  function toggleInventory(force){
    if(typeof force==='boolean') inventoryVisible = force; else inventoryVisible = !inventoryVisible;
    invOverlay.style.display = inventoryVisible ? 'flex' : 'none';
    if(inventoryVisible) renderInventory();
  if(inventoryVisible) pauseGame(); else resumeGame();
  }
  function renderInventory(){
    const list = invPanel.querySelector('#inv-list'); if(!list) return;
    list.innerHTML = '';
    for(let i=0;i<INVENTORY_SLOTS;i++){
      const it = inventory[i];
      const slot = document.createElement('div');
      Object.assign(slot.style, { width:'64px', height:'64px', border:'1px solid rgba(255,255,255,0.25)', borderRadius:'6px', position:'relative', background:'rgba(255,255,255,0.06)' });
      if(it){
        const icon = document.createElement('div');
        Object.assign(icon.style, { position:'absolute', left:'8px', top:'8px', width:'48px', height:'48px', borderRadius:'6px', background: it.color });
        const qty = document.createElement('div'); qty.textContent = it.qty;
        Object.assign(qty.style, { position:'absolute', right:'6px', bottom:'4px', padding:'2px 4px', fontSize:'12px', background:'rgba(0,0,0,0.6)', borderRadius:'4px', color:'#fff' });
        slot.appendChild(icon); slot.appendChild(qty);
        slot.title = it.name + ` x${it.qty}`;
      }
      list.appendChild(slot);
    }
  }
  function addToInventory(item){
    // 既存スタック加算（最大 STACK_MAX）
    for(let i=0;i<INVENTORY_SLOTS;i++){
      const it = inventory[i];
      if(it && it.kind===item.kind && it.name===item.name && it.qty < STACK_MAX){
        it.qty = Math.min(STACK_MAX, it.qty + 1);
        renderInventory();
        return true;
      }
    }
    // 空スロットに新規配置
    for(let i=0;i<INVENTORY_SLOTS;i++){
      if(!inventory[i]){
        inventory[i] = { ...item, qty:1 };
        renderInventory();
        return true;
      }
    }
    // 満杯（必要なら通知）
    return false;
  }
  // Simple pickup spawner
  // uses global pickupGroup defined earlier
  function makePickup(kind, name, color=0x66e0ff){
    const geo = new BoxGeometry(0.22, 0.22, 0.22);
    const mat = new MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.15, roughness: 0.7, metalness: 0.05 });
    const m = new Mesh(geo, mat); m.castShadow = true; m.receiveShadow = true;
    m.userData.interactable = 'pickup'; m.userData.kind = kind; m.userData.name = name; m.userData.color = '#'+new Color(color).getHexString();
    return m;
  }
  function spawnPickups(nScrap=14, nSmall=8, nBig=4){
    function place(m){
      const onX = Math.random()<0.5;
      if(onX){ m.position.set((Math.random()*2-1)*60, 0.12, (Math.random()<0.5? 6.5 : -6.5) + (Math.random()*2-1)*4); }
      else { m.position.set((Math.random()<0.5? 6.5 : -6.5) + (Math.random()*2-1)*4, 0.12, (Math.random()*2-1)*60); }
      pickupGroup.add(m); interactables.push(m);
      addCollider(m.position.x, m.position.z, 0.30);
    }
    for(let i=0;i<nScrap;i++) place(makePickup('scrap','スクラップ',[0x66e0ff,0xff71c5,0x3dff7a,0xffef55][(Math.random()*4)|0]));
    for(let i=0;i<nSmall;i++) place(makePickup('battery_small','小バッテリー',0xaad16a));
    for(let i=0;i<nBig;i++) place(makePickup('battery_big','大バッテリー',0xffc84d));
  }
  // 必須アイテムの仮スポーン（座標は暫定）
  function spawnStoryItems(){
    function placeAt(x,z, m){ m.position.set(x, 0.12, z); pickupGroup.add(m); interactables.push(m); }
    // 変電所付近
    placeAt(10.0, -6.5, makePickup('battery_cell','電源セル',0x55ccff));
    // 管制室
    placeAt(-8.0, 5.8, makePickup('access_key','アクセスキー',0x9b6cff));
    // 研究棠
    placeAt(3.5, 9.0, makePickup('boot_chip','起動チップ',0x52e07a));
  }

  // full map overlay (toggle with 'm')
  let mapVisible = false;
  const mapOverlay = document.createElement('div');
  mapOverlay.id = 'map-overlay';
  Object.assign(mapOverlay.style, { position:'fixed', left:'0', top:'0', width:'100%', height:'100%', display:'none', background:'rgba(0,0,0,0.65)', zIndex:'9999', alignItems:'center', justifyContent:'center' });
  const mapCanvas = document.createElement('canvas');
  const mapCtx = mapCanvas.getContext('2d');
  mapOverlay.appendChild(mapCanvas);
  document.body.appendChild(mapOverlay);
  function sizeMapCanvas(){
    const s = Math.min(window.innerWidth, window.innerHeight) * 0.9;
    mapCanvas.width = Math.max(400, Math.floor(s));
    mapCanvas.height = mapCanvas.width; // square
    mapCanvas.style.boxShadow = '0 0 24px rgba(0,0,0,0.6)';
    mapCanvas.style.border = '2px solid rgba(255,255,255,0.2)';
  }
  sizeMapCanvas();
  // settings overlay (toggle with 'o')
  let settingsVisible = false;
  const settingsOverlay = document.createElement('div');
  settingsOverlay.id = 'settings-overlay';
  Object.assign(settingsOverlay.style, { position:'fixed', left:'0', top:'0', width:'100%', height:'100%', display:'none', background:'rgba(0,0,0,0.6)', zIndex:'9999', alignItems:'center', justifyContent:'center' });
  const settingsPanel = document.createElement('div');
  Object.assign(settingsPanel.style, { background:'rgba(20,22,26,0.95)', color:'#fff', padding:'16px 18px', borderRadius:'8px', minWidth:'320px', boxShadow:'0 8px 24px rgba(0,0,0,0.5)' });
  settingsPanel.innerHTML = `
    <div style="font-size:18px;font-weight:700;margin-bottom:12px">設定</div>
    <div style="margin:10px 0">
      <label for="draw-range">描画範囲（チャンク半径）: <span id="draw-value"></span></label>
      <input id="draw-range" type="range" min="4" max="12" step="1" value="8" style="width:100%" />
    </div>
    <div style="margin:10px 0;color:#cfd8ff">読み込み範囲は 4 チャンクで固定</div>
    <div style="margin-top:12px;text-align:right"><button id="close-settings" style="padding:6px 10px;border-radius:6px;border:0;background:#445; color:#fff">閉じる (O)</button></div>
  `;
  settingsOverlay.appendChild(settingsPanel);
  document.body.appendChild(settingsOverlay);
  function toggleSettings(force){
    if(typeof force==='boolean') settingsVisible = force; else settingsVisible = !settingsVisible;
    settingsOverlay.style.display = settingsVisible ? 'flex' : 'none';
  if(settingsVisible) pauseGame(); else resumeGame();
  }
  function toggleMap(force){
    if(typeof force==='boolean') mapVisible = force; else mapVisible = !mapVisible;
    mapOverlay.style.display = mapVisible ? 'flex' : 'none';
  if(mapVisible) pauseGame(); else resumeGame();
  }
  // draw distance (chunks)
  let drawChunkRadius = parseInt(localStorage.getItem('drawChunks')||'8',10);
  drawChunkRadius = Math.max(4, Math.min(12, isNaN(drawChunkRadius)?8:drawChunkRadius));
  const drawInput = settingsPanel.querySelector('#draw-range');
  const drawValue = settingsPanel.querySelector('#draw-value');
  const closeBtn = settingsPanel.querySelector('#close-settings');
  if(drawInput && drawValue){
    drawInput.value = String(drawChunkRadius);
    drawValue.textContent = `${drawChunkRadius} チャンク`;
    drawInput.addEventListener('input', ()=>{
      drawChunkRadius = Math.max(4, Math.min(12, parseInt(drawInput.value,10)||8));
      drawValue.textContent = `${drawChunkRadius} チャンク`;
      localStorage.setItem('drawChunks', String(drawChunkRadius));
    });
  }
  if(closeBtn){ closeBtn.addEventListener('click', ()=> toggleSettings(false)); }
  // helper: world->map
  const halfSize = terrainSize/2;
  function w2mX(x, size){ return (x + halfSize) / terrainSize * size; }
  function w2mZ(z, size){ return (z + halfSize) / terrainSize * size; }
  function drawMap(){
    const W = mapCanvas.width, H = mapCanvas.height; const size = W;
    // background grid
    mapCtx.clearRect(0,0,W,H);
    mapCtx.fillStyle = '#131518'; mapCtx.fillRect(0,0,W,H);
    // grid lines
    mapCtx.strokeStyle = 'rgba(255,255,255,0.06)'; mapCtx.lineWidth = 1;
    const grid = 10; // 10 cells each side
    for(let i=1;i<grid;i++){
      const t = i/grid; const p = Math.floor(t*W)+0.5; mapCtx.beginPath(); mapCtx.moveTo(p,0); mapCtx.lineTo(p,H); mapCtx.stroke(); mapCtx.beginPath(); mapCtx.moveTo(0,p); mapCtx.lineTo(W,p); mapCtx.stroke();
    }
    // roads
    const roadW = 14; // width in meters
    mapCtx.fillStyle = '#3f4449';
    // x-road
    const yRoad = Math.floor(w2mZ(0, size)); const hpx = Math.max(2, Math.floor((roadW/terrainSize)*size));
    mapCtx.fillRect(0, yRoad - hpx/2, size, hpx);
    // z-road
    const xRoad = Math.floor(w2mX(0, size)); const wpx = Math.max(2, Math.floor((roadW/terrainSize)*size));
    mapCtx.fillRect(xRoad - wpx/2, 0, wpx, size);
    // city towers
    if(Array.isArray(cityTowers) && cityTowers.length){
      for(const t of cityTowers){
        const cx = w2mX(t.x, size); const cz = w2mZ(t.z, size);
        const rad = Math.max(3, (t.radius / terrainSize) * size * 2.1);
        mapCtx.fillStyle = 'rgba(90, 206, 255, 0.25)';
        mapCtx.strokeStyle = 'rgba(90, 206, 255, 0.6)'; mapCtx.lineWidth = 1.4;
        mapCtx.beginPath(); mapCtx.arc(cx, cz, rad, 0, Math.PI*2); mapCtx.fill(); mapCtx.stroke();
      }
    }
    if(Array.isArray(skybridges) && skybridges.length){
      mapCtx.strokeStyle = 'rgba(255, 78, 163, 0.45)'; mapCtx.lineWidth = 1.8;
      for(const br of skybridges){
        mapCtx.beginPath();
        mapCtx.moveTo(w2mX(br.ax, size), w2mZ(br.az, size));
        mapCtx.lineTo(w2mX(br.bx, size), w2mZ(br.bz, size));
        mapCtx.stroke();
      }
    }
    // lamps
    if(Array.isArray(lampPositions)){
      mapCtx.fillStyle = '#ffdca8';
      for(const lp of lampPositions){ const px = w2mX(lp.x, size), pz = w2mZ(lp.z, size); mapCtx.fillRect(px-1, pz-1, 2, 2); }
    }
    // utility poles
    if(Array.isArray(utilPoles)){
      mapCtx.fillStyle = '#a8cfff';
      for(const up of utilPoles){ const px = w2mX(up.head.position.x, size), pz = w2mZ(up.head.position.z, size); mapCtx.fillRect(px-1, pz-1, 2, 2); }
    }
    // barricades
    if(Array.isArray(barricadePositions)){
      mapCtx.fillStyle = '#c0c5cc';
      for(const bp of barricadePositions){ const px = w2mX(bp.x, size), pz = w2mZ(bp.z, size); mapCtx.fillRect(px-1, pz-1, 2, 2); }
    }
    // signs
    if(signGroup && signGroup.children){ mapCtx.fillStyle = '#e6f2ff'; signGroup.children.forEach(s=>{ const px=w2mX(s.position.x,size), pz=w2mZ(s.position.z,size); mapCtx.fillRect(px-1,pz-1,2,2); }); }
    // cars
    if(carGroup && carGroup.children){ mapCtx.fillStyle = '#ff6b6b'; carGroup.children.forEach(c=>{ const px=w2mX(c.position.x,size), pz=w2mZ(c.position.z,size); mapCtx.fillRect(px-2,pz-2,4,4); }); }
    // player arrow
    const px = w2mX(camera.position.x, size), pz = w2mZ(camera.position.z, size);
    const ang = yaw; // Y-axis yaw
    const len = 10;
    const ax = Math.cos(ang), az = Math.sin(ang);
    mapCtx.fillStyle = '#ffffff'; mapCtx.strokeStyle = '#ffffff';
    mapCtx.beginPath();
    mapCtx.moveTo(px + ax*len, pz + az*len);
    mapCtx.lineTo(px - az*6, pz + ax*6);
    mapCtx.lineTo(px + az*6, pz - ax*6);
    mapCtx.closePath(); mapCtx.fill();
    // border
    mapCtx.strokeStyle = 'rgba(255,255,255,0.25)'; mapCtx.lineWidth = 2; mapCtx.strokeRect(1,1,size-2,size-2);
  }

  // minimap (always-on, bottom-right)
  const miniWrap = document.createElement('div');
  miniWrap.id = 'minimap';
  Object.assign(miniWrap.style, { position:'fixed', right:'12px', bottom:'12px', zIndex:'9998', pointerEvents:'none' });
  const miniCanvas = document.createElement('canvas'); const miniCtx = miniCanvas.getContext('2d'); miniWrap.appendChild(miniCanvas); document.body.appendChild(miniWrap);
  function sizeMiniMapCanvas(){
    const s = Math.max(140, Math.min(260, Math.floor(Math.min(window.innerWidth, window.innerHeight)*0.22)));
    miniCanvas.width = s; miniCanvas.height = s;
    miniCanvas.style.border = '1px solid rgba(255,255,255,0.25)'; miniCanvas.style.boxShadow = '0 0 12px rgba(0,0,0,0.5)';
  }
  sizeMiniMapCanvas();
  function drawMiniMap(){
    const W = miniCanvas.width, H = miniCanvas.height; const size = W;
    miniCtx.clearRect(0,0,W,H);
    // background
    miniCtx.fillStyle = 'rgba(10,12,14,0.9)'; miniCtx.fillRect(0,0,W,H);
    // roads
    const roadW = 14; miniCtx.fillStyle = '#3f4449';
    const yRoad = Math.floor(w2mZ(0, size)); const hpx = Math.max(2, Math.floor((roadW/terrainSize)*size)); miniCtx.fillRect(0, yRoad - hpx/2, size, hpx);
    const xRoad = Math.floor(w2mX(0, size)); const wpx = Math.max(2, Math.floor((roadW/terrainSize)*size)); miniCtx.fillRect(xRoad - wpx/2, 0, wpx, size);
    if(Array.isArray(cityTowers) && cityTowers.length){
      for(const t of cityTowers){
        const cx = w2mX(t.x, size); const cz = w2mZ(t.z, size);
        const rad = Math.max(2, (t.radius / terrainSize) * size * 2.0);
        miniCtx.fillStyle = 'rgba(90, 206, 255, 0.25)'; miniCtx.strokeStyle = 'rgba(90, 206, 255, 0.55)'; miniCtx.lineWidth = 1.0;
        miniCtx.beginPath(); miniCtx.arc(cx, cz, rad, 0, Math.PI*2); miniCtx.fill(); miniCtx.stroke();
      }
    }
    if(Array.isArray(skybridges) && skybridges.length){
      miniCtx.strokeStyle = 'rgba(255, 78, 163, 0.4)'; miniCtx.lineWidth = 1.2;
      for(const br of skybridges){
        miniCtx.beginPath();
        miniCtx.moveTo(w2mX(br.ax, size), w2mZ(br.az, size));
        miniCtx.lineTo(w2mX(br.bx, size), w2mZ(br.bz, size));
        miniCtx.stroke();
      }
    }
    // player arrow
    const px = w2mX(camera.position.x, size), pz = w2mZ(camera.position.z, size);
    const ang = yaw; const len = 8; const ax = Math.cos(ang), az = Math.sin(ang);
    miniCtx.fillStyle = '#ffffff'; miniCtx.beginPath();
    miniCtx.moveTo(px + ax*len, pz + az*len);
    miniCtx.lineTo(px - az*5, pz + ax*5);
    miniCtx.lineTo(px + az*5, pz - ax*5);
    miniCtx.closePath(); miniCtx.fill();
    // border
    miniCtx.strokeStyle = 'rgba(255,255,255,0.2)'; miniCtx.lineWidth = 1; miniCtx.strokeRect(0.5,0.5,size-1,size-1);
  }

  // pointer lock button
  const startBtn = document.getElementById('startBtn');
  startBtn.addEventListener('click', ()=>{
    document.body.requestPointerLock();
    startAudio();
    document.getElementById('overlay').style.display = 'none';
  });

  // audio: wind only (no birds) for post-apocalypse
  let audioStarted = false;
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  function createNoiseBuffer(duration){
    const rate = audioCtx.sampleRate; const buf = audioCtx.createBuffer(1, rate*duration, rate);
    const data = buf.getChannelData(0); for(let i=0;i<data.length;i++) data[i] = (Math.random()*2-1)*0.4; return buf;
  }
  function startAudio(){
    if(audioStarted) return; audioStarted = true;
    // 一部ブラウザでの自動停止対策
    if(audioCtx.state === 'suspended'){
      try{ audioCtx.resume(); }catch(e){}
    }
    const noise = audioCtx.createBufferSource(); noise.buffer = createNoiseBuffer(2.0); noise.loop = true;
    const lp = audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=500;
    const hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=80;
    const gain = audioCtx.createGain(); gain.gain.value = 0.12;
    noise.connect(lp); lp.connect(hp); hp.connect(gain); gain.connect(audioCtx.destination); noise.start();
  }

  // spark sound (short, noisy, bright)
  function playSparkAt(pos){
    // simple one-shot using white noise shaped with bandpass and exponential decay
    const src = audioCtx.createBufferSource(); src.buffer = createNoiseBuffer(0.2); src.loop = false;
    const bp = audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value = 3500; bp.Q.value = 3.5;
    const g = audioCtx.createGain(); g.gain.value = 0.18;
    const t = audioCtx.currentTime;
    g.gain.setValueAtTime(0.18, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.15);
    src.connect(bp); bp.connect(g); g.connect(audioCtx.destination); src.start();
  }

  // footstep (short thump + noise), non-spatial for simplicity
  function playFootstep(strength=1.0){
    const t = audioCtx.currentTime;
    // thump: sine burst
    const osc = audioCtx.createOscillator();
    const og = audioCtx.createGain();
    osc.type = 'sine'; osc.frequency.value = 95 + Math.random()*55; // 95-150 Hz
    og.gain.setValueAtTime(0.0, t);
    og.gain.linearRampToValueAtTime(0.16 * strength, t + 0.008);
    og.gain.exponentialRampToValueAtTime(0.001, t + 0.14);
    osc.connect(og);
    // grit: short noise through bandpass
    const ns = audioCtx.createBufferSource(); ns.buffer = createNoiseBuffer(0.12);
    const bp = audioCtx.createBiquadFilter(); bp.type = 'bandpass'; bp.frequency.value = 900 + Math.random()*800; bp.Q.value = 0.7 + Math.random()*0.8;
    const ng = audioCtx.createGain(); ng.gain.setValueAtTime(0.07 * strength, t); ng.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
    ns.connect(bp); bp.connect(ng);
    // master for the step
    const g = audioCtx.createGain(); g.gain.value = 0.16 * Math.min(1.4, Math.max(0.5, strength)); // overall step volume
    og.connect(g); ng.connect(g); g.connect(audioCtx.destination);
    osc.start(t); osc.stop(t + 0.16);
    ns.start(t); ns.stop(t + 0.14);
  }

  // loop
  const clock = new THREE.Clock();
  let timeElapsed = 0;
  // 足音: 距離ベースの歩幅でトリガー
  let stepAcc = 0; // 累積移動距離（m）
  function animate(){
    requestAnimationFrame(animate);
    const dt = Math.min(0.05, clock.getDelta());
    timeElapsed += dt;
    // ポーズ中は更新を停止してレンダリングのみ
    if(isPaused){
      renderer.render(scene, camera);
      return;
    }
    // 死亡中は入力による移動を止め、死亡地点を俯瞰する三人称カメラに切り替える
    if(isDead){
      // 死亡地点（プレイヤー足元＋少し上）を注視点として記録
      deathFocusPos.set(
        player.node.position.x,
        player.node.position.y + player.eyeOffset * 0.5,
        player.node.position.z
      );
      const desiredPos = deathFocusPos.clone().add(deathCameraOffset);
      // カメラを少しスムーズに追従させる
      camera.position.lerp(desiredPos, 0.1);
      camera.lookAt(deathFocusPos);
      if(!deathOverlayVisible){
        showDeathOverlay();
      }
      // 死亡中はここで早期リターン（敵やエフェクトの更新は続行したければここを調整）
      return;
    }

  // 物理ワールドを進める（最小構成：プレイヤー球体＋地面）
  world.step(1/60, dt, 3);
  // ジャンプクールダウン減衰
  if(jumpCooldown > 0) jumpCooldown = Math.max(0, jumpCooldown - dt);

  const forward = new Vector3(); camera.getWorldDirection(forward); forward.y=0; forward.normalize();
    const right = new Vector3().crossVectors(forward, new Vector3(0,1,0)).normalize();

  // スタミナと速度倍率（ダッシュ／疲労）
  let speedMul = slowMultiplier; // 新デフォルト歩行=旧鈍足
  if(exhausted){
    // 疲労中は鈍足、ダッシュ不可。スタミナ満タンで解除
    dashTime = 0; // 残りダッシュを即座に無効化
    speedMul = slowMultiplier;
    stamina = Math.min(staminaMax, stamina + staminaRegenRate*dt);
    if(stamina >= staminaMax){ exhausted = false; }
  } else {
    // 通常時: ダッシュ残時間／クールダウン
    if(dashTime>0){ speedMul = dashMultiplier; dashTime -= dt; }
    if(dashCooldown>0) dashCooldown -= dt;
    // 押下ダッシュ中はスタミナを継続消費。0 到達で疲労突入
    if(dashHeld){
      const use = staminaUseRate * dt;
      stamina = Math.max(0, stamina - use);
      if(stamina > 0){
        speedMul = Math.max(speedMul, dashMultiplier); // 1.0 まで上げる=旧歩行
      } else {
        exhausted = true; dashTime = 0; // 枯渇で即疲労化
      }
    } else {
      stamina = Math.min(staminaMax, stamina + staminaRegenRate*dt);
    }
  }

    const targetDir = new Vector3(); if(move.forward) targetDir.add(forward); if(move.back) targetDir.sub(forward); if(move.left) targetDir.sub(right); if(move.right) targetDir.add(right); if(targetDir.length()>0) targetDir.normalize();
  const targetVel = targetDir.multiplyScalar(speed*speedMul);
    const dv = new Vector3().subVectors(targetVel, hVel); const dvLen = dv.length(); if(dvLen>0){ const maxA = (targetDir.length()>0?accel:deccel)*dt; const change = Math.min(maxA, dvLen); hVel.add(dv.normalize().multiplyScalar(change)); }
  const moveStep = hVel.clone().multiplyScalar(dt);
  // tentative horizontal move with collision resolution against static colliders
  if(moveStep.x !== 0 || moveStep.z !== 0){
    const tentative = player.node.position.clone();
    tentative.x += moveStep.x; tentative.z += moveStep.z;
    resolveCollisionsXZ(tentative, playerRadius);
    player.node.position.x = tentative.x; player.node.position.z = tentative.z;
  }
  const horizSpeed = hVel.length();

  // --- 垂直移動と落下ダメージ検出（距離ベース） ---
  // 垂直方向の位置は cannon-es のプレイヤー剛体に任せる
  lastVelY = playerBody.velocity.y; // 前フレーム速度（演出用）
  // 横移動後の XZ を物理ボディに反映（縦Yは物理側に任せる）
  playerBody.position.x = player.node.position.x;
  playerBody.position.z = player.node.position.z;
  const bodyY = playerBody.position.y;

  // 落下開始位置の記録
  if(player.grounded){
    // 接地状態から離れた瞬間に記録したいので、ここではリセットのみ
    if(fallStartY === null) fallStartY = bodyY;
  }

  // 簡易接地判定：bodyY がほぼ 0（地面）に近ければ接地とみなす
  const groundY = getGroundYAt(player.node.position.x, player.node.position.z);
  const targetY = groundY;
  const onGround = bodyY <= targetY + 0.05;

  if(onGround){
    if(!player.grounded && fallStartY !== null){
      const fallDist = Math.max(0, fallStartY - targetY);

      if(fallDist >= lethalFallHeight){
        applyDamage(healthMax);
        if(!isDead){
          isDead = true;
        }
      } else if(fallDist >= stunFallHeight){
        const over = fallDist - stunFallHeight;
        const dmg = over * fallDamageScale;
        applyDamage(dmg);
        // 水平速度を一瞬弱めて "止まった" 感を出す
        hVel.multiplyScalar(0.2);
      }
    }
    fallStartY = null;
    player.grounded = true;
  // 地面へスナップして貫通を防ぐ（外部GLTF地形にも追従）
  playerBody.position.y = targetY;
  playerBody.velocity.y = 0;
  } else {
    if(player.grounded){
      // 接地から離れた瞬間に高さを記録
      fallStartY = bodyY;
    }
    player.grounded = false;
  }

  // world.step 後の物理ボディの Y を three.js のプレイヤーに反映
  player.node.position.y = bodyY;
  const eyeHeight = player.eyeOffset;
  // カメラを本体の目線に追従
  camera.position.set(player.node.position.x, player.node.position.y + eyeHeight, player.node.position.z);

    // streetlight flicker update
    const camPos = camera.position;
    // chunk-based visibility helper
    const camCX = Math.floor(camPos.x / CHUNK_SIZE), camCZ = Math.floor(camPos.z / CHUNK_SIZE);
    function inDrawChunks(x, z){
      const cx = Math.floor(x / CHUNK_SIZE), cz = Math.floor(z / CHUNK_SIZE);
      return Math.abs(cx - camCX) <= drawChunkRadius && Math.abs(cz - camCZ) <= drawChunkRadius;
    }

    // Debug: draw colliders near camera when enabled
    if(showColliders){
      // clear previous
      while(debugGroup.children.length){ debugGroup.remove(debugGroup.children[0]); }
      const { circles, segments, boxes } = collectNearby(camera.position.x, camera.position.z, 4);
      // materials
      const matCircle = new THREE.LineBasicMaterial({ color: 0x66e0ff });
      const matSeg = new THREE.LineBasicMaterial({ color: 0xff71c5 });
      const matBox = new THREE.LineBasicMaterial({ color: 0xffef55 });
      // circles
      for(const c of circles){
        const ring = new THREE.RingGeometry(c.r-0.01, c.r+0.01, 24);
        const edges = new THREE.LineSegments(new THREE.EdgesGeometry(ring), matCircle);
        edges.position.set(c.x, 0.02, c.z);
        debugGroup.add(edges);
      }
      // segments (capsules：中心線表示)
      for(const s of segments){
        const geo = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(s.ax, 0.02, s.az),
          new THREE.Vector3(s.bx, 0.02, s.bz),
        ]);
        const line = new THREE.Line(geo, matSeg);
        debugGroup.add(line);
      }
      // boxes（外枠）
      for(const b of boxes){
        const hx = b.half.x, hz = b.half.z;
        const pts = [
          new THREE.Vector3(-hx,0.02,-hz), new THREE.Vector3(hx,0.02,-hz),
          new THREE.Vector3(hx,0.02,hz), new THREE.Vector3(-hx,0.02,hz),
          new THREE.Vector3(-hx,0.02,-hz)
        ];
        const geo = new THREE.BufferGeometry().setFromPoints(pts);
        const line = new THREE.Line(geo, matBox);
        line.position.set(b.cx, 0, b.cz);
        line.rotation.y = Math.atan2(b.sin, b.cos);
        debugGroup.add(line);
      }
    }

    // --- animate fog sheets (slow drift + keep near camera)
    if(Array.isArray(fogSheets)){
      for(const f of fogSheets){
        const m = f.m; const a = timeElapsed*0.05 + f.dir;
        m.position.x += Math.sin(a)*0.05; m.position.z += Math.cos(a)*0.06;
        // softly tether to camera within a radius so they surround the player
        const dx = m.position.x - camera.position.x; const dz = m.position.z - camera.position.z; const r2 = dx*dx + dz*dz; const maxR = 260;
        if(r2 > maxR*maxR){
          const ang = Math.random()*Math.PI*2; const r = 120 + Math.random()*120;
          m.position.set(camera.position.x + Math.cos(ang)*r, m.position.y, camera.position.z + Math.sin(ang)*r);
        }
      }
    }

    // (rain update removed)

    // Flashlight battery drain and intensity
    if(batterySegments>0){
      // convert rate (segments per minute) to per second drain
      const perSec = batteryDrainRate/60;
      batteryAccum += perSec * dt;
      if(batteryAccum >= 1){ batteryAccum -= 1; batterySegments = Math.max(0, batterySegments-1); updateBatteryUI(); }
    }
  const segRatio = batterySegments / batteryMaxSegments;
  flashlightSpot.intensity = 3.0 * segRatio;
  flashlightSpot.distance = 16 + 8 * segRatio;
  flashlightPoint.intensity = 0.4 * segRatio;
  // update spotlight target to camera forward point
  const forwardDir = new Vector3(); camera.getWorldDirection(forwardDir);
  forwardDir.normalize();
  flashlightTarget.position.copy(camera.position).addScaledVector(forwardDir, 10);

    // Interact raycast & highlight
    interactRay.setFromCamera(new Vector3(0,0), camera);
    const hits = interactRay.intersectObjects(interactables, false);
    let target = null;
    for(let i=0;i<hits.length;i++){ if(hits[i].distance <= interactRay.far){ target = hits[i].object; break; } }
    if(highlighted && highlighted !== target){
      highlighted.scale.setScalar(highlightedScale);
      if(highlightedPrevMat){ highlighted.material.emissiveIntensity = highlightedPrevMat.emissiveIntensity; }
      highlighted = null; highlightedPrevMat = null; prompt.style.display = 'none';
    }
    if(target && target.userData && target.userData.interactable){
      if(!highlighted){ highlighted = target; highlightedScale = highlighted.scale.x; highlightedPrevMat = { emissiveIntensity: (target.material && target.material.emissiveIntensity)||0 };
      }
      highlighted.scale.setScalar(highlightedScale*1.15);
      if(highlighted.material) highlighted.material.emissiveIntensity = 0.6;
      let label;
      if(target.userData.interactable==='pickup'){
        label = `【E】拾う: ${target.userData.name}`;
        if(target.userData.kind==='battery_small') label += '（+1）';
        if(target.userData.kind==='battery_big') label += '（+3）';
      } else if(target.userData.interactable==='gate'){
        label = canActivateGate()? '【E】シェルター起動' : '起動モジュールが不足しています (3個必要)';
      } else {
        label = '【E】アクション';
      }
      prompt.textContent = label; prompt.style.display = 'block';
    }
    // Arms bobbing and reach animation
    const moveAmount = hVel.length();
  // grounded は player.grounded を使用（未定義参照の修正）
  const grounded = player.grounded === true;
    armBob += dt * (grounded ? (4.0 + 2.0*Math.min(1, moveAmount)) : 0);
  const bob = grounded ? Math.sin(armBob) * 0.05 * Math.min(1, moveAmount*0.4) : 0;
    rightShoulder.rotation.z = 0.15 + bob*0.6;
  rightShoulder.rotation.x = -0.2 + Math.cos(armBob*0.5)*0.05;
  rightElbow.rotation.x = -0.6 + Math.sin(armBob+Math.PI*0.2)*0.15;
    if(armReachT > 0){ armReachT = Math.max(0, armReachT - dt*3.5); }
    const reachK = armReachT>0 ? (1 - Math.pow(1-armReachT, 2)) : 0;
    rightShoulder.rotation.x -= 0.8*reachK; rightElbow.rotation.x -= 0.6*reachK; rightWrist.rotation.x += 0.4*reachK; armsGroup.position.z = -0.36 - 0.22*reachK;
    // Finger curl animation (grip when reaching or on movement emphasis)
    const baseGrip = reachK; // 0..1 from interaction reach
    const moveGrip = Math.min(1, moveAmount*0.15);
    const grip = Math.min(1, baseGrip * 0.8 + moveGrip*0.4);
  function applyFingerSet(fingers, g){
      for(const f of fingers){
        // thumb has more yaw-based opposition; use different curl speed
        const thumbMul = f.isThumb ? 0.7 : 1.0;
        const k = g * thumbMul;
        // base (proximal) flex (negative x rotates downward since geometry points -Y downward)
        f.base.rotation.x = -1.2 * k;
        f.midG.rotation.x = -1.1 * k;
        f.tipG.rotation.x = -1.0 * k;
        if(f.isThumb){
      f.base.rotation.y = (f.baseYaw||0) + 0.15 * k; // slight opposition adjustment
        }
      }
    }
    applyFingerSet(rightFingers, grip);
    applyFingerSet(leftFingers, grip*0.6); // left hand stays more relaxed
    const lightActiveRange = 180; // keep light update threshold as safety
    for(let i=0;i<lampLights.length;i++){
      const light = lampLights[i]; const head = lampMeshes[i]; const f = lampFlick[i];
      const near = inDrawChunks(light.position.x, light.position.z);
      if(!near){ light.visible = false; if(head) head.visible = false; continue; }
      light.visible = true; if(head) head.visible = true;
      const outage = (Math.random() < f.offProb*dt) ? 0.0 : 1.0;
      const wave = 0.6 + 0.4*Math.abs(Math.sin(timeElapsed*f.speed + f.jitter));
      light.intensity = f.base * wave * outage;
      if (head && head.material) head.material.emissiveIntensity = 0.5 + 0.7*wave*outage;
    }

    // dust gentle drift
    const pAttr = dustGeo.getAttribute('position');
    for(let i=0;i<dustCount; i++){
      const ix = i*3, iy = ix+1, iz = ix+2;
      let x = pAttr.array[ix], y = pAttr.array[iy], z = pAttr.array[iz];
      x += Math.sin((i*13.1 + timeElapsed*0.3))*0.02;
      z += Math.cos((i*7.7 + timeElapsed*0.27))*0.02;
      y += (Math.sin((i*5.3 + timeElapsed*0.8))*0.003);
      // wrap to keep near origin
      if(x>baseXZ) x=-baseXZ; if(x<-baseXZ) x=baseXZ; if(z>baseXZ) z=-baseXZ; if(z<-baseXZ) z=baseXZ;
      pAttr.array[ix]=x; pAttr.array[iy]=y; pAttr.array[iz]=z;
    }
    pAttr.needsUpdate = true;

  const coordsEl = document.getElementById('coords'); if(coordsEl){ coordsEl.textContent = `x:${player.node.position.x.toFixed(2)} y:${(player.node.position.y+player.eyeOffset).toFixed(2)} z:${player.node.position.z.toFixed(2)}`; }
    const stBar = document.getElementById('stamina-bar');
    if(stBar){
      const ratio = Math.max(0, Math.min(1, stamina / staminaMax));
      stBar.style.width = `${ratio * 100}%`;
      const dashActive = (!exhausted) && ((dashTime>0) || (dashHeld && stamina>0));
      // 色分岐: 疲労中はグレー、ダッシュ中はシアン、低スタミナは警告色
      if(exhausted){
        stBar.style.background = 'linear-gradient(90deg,#bbb,#777)';
      } else if(dashActive){
        stBar.style.background = 'linear-gradient(90deg,#6ff,#0cf)';
      } else if(ratio < 0.1){
        stBar.style.background = 'linear-gradient(90deg,#f66,#d00)';
      } else if(ratio < 0.3){
        stBar.style.background = 'linear-gradient(90deg,#fc6,#f80)';
      } else {
        stBar.style.background = 'linear-gradient(90deg,#7cf,#06f)';
      }
    }
    const hpBar = document.getElementById('health-bar');
    if(hpBar){
      const ratio = Math.max(0, Math.min(1, health / healthMax));
      hpBar.style.width = `${ratio * 100}%`;
      // color: green -> yellow -> red
      const r = Math.floor(255 * (1 - ratio));
      const g = Math.floor(200 * (0.4 + 0.6*ratio));
      const color = `rgb(${r}, ${g}, 40)`;
      hpBar.style.background = color;
      const hpText = document.getElementById('health-text');
      if(hpText) hpText.textContent = `${Math.round(health)} / ${Math.round(healthMax)}`;
    }

    // 足音: 地上かつ移動時、移動距離で歩幅を超えたら再生
    if(audioStarted && grounded && horizSpeed > 0.2){
      stepAcc += horizSpeed * dt; // m/frame
      const dashActive = (!exhausted) && ((dashTime>0) || (dashHeld && stamina>0));
      const stride = exhausted ? 1.9 : (dashActive ? 1.2 : 1.8);
      const strength = exhausted ? 0.8 : (dashActive ? 1.2 : 1.0);
      if(stepAcc >= stride){
        playFootstep(strength);
        stepAcc -= stride;
      }
    } else {
      // 立ち止まり・空中ではリセット（次の一歩を安定化）
      stepAcc = 0;
    }

  // update maps
  if(mapVisible){ drawMap(); }
  drawMiniMap();

  // update enemies (shadow humanoids). Chunk-based visibility + いびつな歩行
  // グローバルテンプレートは保持しつつ、個体マテリアル time を後段で更新
    for(let i=0;i<enemies.length;i++){
      const e = enemies[i]; const n = e.node; const p = e.parts;
      if(!inDrawChunks(n.position.x, n.position.z)){ n.visible=false; continue; } else n.visible=true;
      e.t += dt; e.sway += dt*1.0;
  // フリーズ挙動
      if(e.freeze <= 0 && Math.random()<0.003){ e.freeze = 0.25 + Math.random()*0.55; }
      if(e.freeze>0) e.freeze -= dt;
  // 個体マテリアルの時間更新（脈動・有機変形）
  if(e.mat && e.mat.uniforms){ e.mat.uniforms.time.value = timeElapsed; }
  // 進行方向ノイズ + 急旋回（不規則性をやや強く）
  e.dir += (Math.sin(e.t*0.21 + i)*0.6 + Math.sin(e.t*0.44 + i*1.1)*0.35)*0.07*dt;
  if(Math.random()<0.0016){ e.dir += (Math.random()*2-1)*Math.PI*0.85; }
  const baseMul = 0.5 + 0.5*Math.abs(Math.sin(e.sway*0.78 + i));
  const sp = e.speed * (e.freeze>0?0.03:baseMul);
      const mx = Math.cos(e.dir)*sp*dt; const mz = Math.sin(e.dir)*sp*dt;
      if(mx||mz){
        const tentative=n.position.clone(); tentative.x+=mx; tentative.z+=mz;
        resolveCollisionsXZ(tentative,0.4);
        n.position.x=tentative.x; n.position.z=tentative.z;
      }
      // 向き補間
  const targetYaw = Math.atan2(mz, mx);
      if(isFinite(targetYaw)){ let ay=n.rotation.y; let dy=((targetYaw - ay + Math.PI)%(Math.PI*2))-Math.PI; n.rotation.y = ay + dy*Math.min(1,6*dt);}      
  // 歩行位相 + くねくね位相
  const gaitMul = e.freeze>0?0.05:(0.55+0.65*baseMul); 
  e.walkPhase += dt*e.walkRate*gaitMul; 
  const ph=e.walkPhase; const strideSin = Math.sin(ph);
  const wob = Math.sin(e.t*e.wobbleA + i*0.7)*0.5 + Math.sin(e.t*e.wobbleB + i*1.3)*0.5;
  // 四足ビースト用アニメ分岐
  if(p.kind==='beast'){
    // 対角のトロット: 前左と後右、前右と後左
    const fL = Math.sin(ph);
    const fR = Math.sin(ph + Math.PI);
    const hL = Math.sin(ph + Math.PI);
    const hR = Math.sin(ph);
    // 背骨のうねり
    if(p.spineRoot){ p.spineRoot.rotation.y = Math.sin(ph*0.35 + wob*0.3)*0.07; p.spineRoot.rotation.x = Math.sin(ph*0.22 + wob*0.2) * (0.05 + e.bendAmp*0.22); }
    if(p.spineA){ p.spineA.rotation.x = (Math.sin(ph*0.45) + wob*0.55) * (0.05 + e.bendAmp*0.26); }
    if(p.spineB){ p.spineB.rotation.x = (Math.sin(ph*0.50+0.4) + wob*0.55) * (0.055 + e.bendAmp*0.28); }
    if(p.spineC){ p.spineC.rotation.x = (Math.sin(ph*0.55+0.8) + wob*0.55) * (0.06 + e.bendAmp*0.30); }
    if(p.spineD){ p.spineD.rotation.x = (Math.sin(ph*0.60+1.2) + wob*0.55) * (0.065 + e.bendAmp*0.33); }
    if(p.chest){
      // 呼吸スケール: 胸郭と腹部をわずかに膨張/収縮
      const breath = Math.sin(e.t*0.6 + i*0.3);
      p.chest.rotation.z = Math.sin(e.t*1.9 + wob)*0.05;
      p.chest.scale.y = 1.0 + 0.02*breath;
      p.chest.scale.x = 1.0 + 0.01*breath;
      if(p.abdomen){ p.abdomen.scale.y = 1.0 + 0.015*breath; }
    }

  // --- Player vs Enemy collision (円同士) ---
  // プレイヤー本体を敵半径 + playerRadius で押し戻す
  const px = player.node.position.x; const pz = player.node.position.z;
    for(let i=0;i<enemies.length;i++){
      const e = enemies[i]; const n = e.node;
      if(!n.visible) continue; // 遠距離非表示時は省略
      const dx = px - n.position.x; const dz = pz - n.position.z;
      const dist2 = dx*dx + dz*dz;
      const r = playerRadius + (e.colR||0.8);
      if(dist2 > 0 && dist2 < r*r){
        const dist = Math.sqrt(dist2);
        const push = (r - dist);
        const inv = 1.0 / Math.max(0.0001, dist);
  player.node.position.x += dx * inv * push;
  player.node.position.z += dz * inv * push;
      }
    }
    // 首・頭・顎
    if(p.neck){ p.neck.rotation.x = 0.1 + Math.sin(e.t*1.2 + wob)*0.08; p.neck.rotation.y = Math.sin(e.t*0.8 + i)*0.1; }
    if(p.head){ p.head.rotation.y = Math.sin(e.t*0.7 + wob + i)*0.18; p.head.rotation.x = Math.sin(e.t*0.9 + i*0.5)*0.06; }
    if(p.jaw){
      const jawPulse = (Math.random()<0.004 ? 0.6 : 0.0);
      const jawOpen = 0.18 + 0.28*(0.5+0.5*Math.sin(e.t*1.3 + wob)) + jawPulse;
      p.jaw.rotation.x = -Math.min(0.85, jawOpen);
    }
  // 前肢（長い）+ 側方スプレイ（アウトワードステップ）
  if(p.scapulaL){ p.scapulaL.rotation.z = 0.15*Math.sin(e.t*1.2 + wob)*e.shoulderRollAmp; }
  if(p.scapulaR){ p.scapulaR.rotation.z = -0.15*Math.sin(e.t*1.2 + wob)*e.shoulderRollAmp; }
  const splayL = Math.max(0, fL); // 前に出る局面でのみ外側へ
  const splayR = Math.max(0, fR);
  if(p.scapulaL){ p.scapulaL.position.x = (e.baseScapulaLX||p.scapulaL.position.x) + e.foreSplayAmp*(0.2 + 0.8*splayL); p.scapulaL.rotation.y = 0.12*splayL; }
  if(p.scapulaR){ p.scapulaR.position.x = (e.baseScapulaRX||p.scapulaR.position.x) - e.foreSplayAmp*(0.2 + 0.8*splayR); p.scapulaR.rotation.y = -0.12*splayR; }
  if(p.shoulderL){ p.shoulderL.position.x = 0.02 + 0.06*splayL; p.shoulderL.rotation.x = -0.9*fL*e.armAmp; }
    if(p.elbowL){ p.elbowL.rotation.x = 0.4 + 0.7*Math.abs(fL); }
    if(p.wristL){ p.wristL.rotation.x = -0.4*fL; }
    if(p.clawL){ p.clawL.rotation.x = Math.max(0, -fL)*0.5; }
  if(p.shoulderR){ p.shoulderR.position.x = -0.02 - 0.06*splayR; p.shoulderR.rotation.x = -0.9*fR*e.armAmp; }
    if(p.elbowR){ p.elbowR.rotation.x = 0.4 + 0.7*Math.abs(fR); }
    if(p.wristR){ p.wristR.rotation.x = -0.4*fR; }
    if(p.clawR){ p.clawR.rotation.x = Math.max(0, -fR)*0.5; }
    // 後肢
    if(p.hipL){ p.hipL.rotation.x = 0.8*hL*e.legAmp; }
    if(p.kneeL){ p.kneeL.rotation.x = 0.5 + 1.0*Math.abs(hL); }
    if(p.ankleL){ p.ankleL.rotation.x = -0.6*hL; }
    if(p.hoofL){ p.hoofL.rotation.x = Math.max(0,-hL)*0.45; }
    if(p.hipR){ p.hipR.rotation.x = 0.8*hR*e.legAmp; }
    if(p.kneeR){ p.kneeR.rotation.x = 0.5 + 1.0*Math.abs(hR); }
    if(p.ankleR){ p.ankleR.rotation.x = -0.6*hR; }
    if(p.hoofR){ p.hoofR.rotation.x = Math.max(0,-hR)*0.45; }
    // 全体の上下バウンド
    if(p.spineRoot){ p.spineRoot.position.y = (e.baseSpineY||p.spineRoot.position.y) + Math.abs(Math.sin(ph*2.0))*0.06; }
    // 微痙攣を前足の爪先に少し
    const spasm = (Math.random()<0.2) ? 0.0 : (Math.sin(e.t*40.0)*0.15);
    if(p.wristL){ p.wristL.rotation.z += spasm*0.1; }
    if(p.wristR){ p.wristR.rotation.z -= spasm*0.1; }
    // 人型用処理をスキップ
    continue;
  }
  // 腕: 鎖骨ロール→肩→肘→手（不気味に振幅強、肘は逆相で突っ張る瞬間）
  if(p.clavicleL){ p.clavicleL.rotation.z = Math.sin(e.t*1.3 + i)*0.15*e.shoulderRollAmp; }
  if(p.clavicleR){ p.clavicleR.rotation.z = -Math.sin(e.t*1.3 + i)*0.15*e.shoulderRollAmp; }
  if(p.shoulderL){ p.shoulderL.rotation.x = strideSin * e.armAmp; p.elbowL.rotation.x = -Math.abs(Math.sin(ph*0.95))*0.65; p.wristL.rotation.x = Math.sin(ph*1.4)*0.22; }
  if(p.shoulderR){ p.shoulderR.rotation.x = Math.sin(ph+Math.PI) * e.armAmp; p.elbowR.rotation.x = -Math.abs(Math.sin((ph+Math.PI)*0.95))*0.65; p.wristR.rotation.x = Math.sin((ph+Math.PI)*1.4)*0.22; }
  // 脚: 股→膝→足首→足先ローリング（足のリーチを誇張）
  if(p.hipL){ p.hipL.rotation.x = Math.sin(ph+Math.PI)*e.legAmp; p.kneeL.rotation.x = Math.abs(Math.sin(ph+Math.PI))*1.0; p.ankleL.rotation.x = -Math.sin(ph+Math.PI)*0.34; p.footL.rotation.x = -Math.max(0, Math.sin(ph+Math.PI))*0.28; }
  if(p.hipR){ p.hipR.rotation.x = Math.sin(ph)*e.legAmp; p.kneeR.rotation.x = Math.abs(Math.sin(ph))*1.0; p.ankleR.rotation.x = -Math.sin(ph)*0.34; p.footR.rotation.x = -Math.max(0, Math.sin(ph))*0.28; }
  // 体幹の大きなくねり + 側方スライド（spineMidも活用）
  if(p.lowerTorso){ p.lowerTorso.rotation.y = Math.sin(ph*0.5 + wob*0.3) * 0.08; }
  if(p.spineMid){ p.spineMid.rotation.y = -Math.sin(ph*0.45 + wob*0.25) * 0.06; p.spineMid.rotation.x = wob * 0.05; }
  if(p.upperTorso){ p.upperTorso.rotation.y = -Math.sin(ph*0.5 + wob*0.35) * 0.1; p.upperTorso.rotation.z = e.lean + Math.sin(e.t*2.1 + wob)*0.05; p.upperTorso.rotation.x = (Math.sin(ph*0.45) + wob*0.5) * (0.03 + e.bendAmp*0.35); }
  if(e.sideSlide && p.hips){ p.hips.position.x = Math.sin(e.t*0.9 + i*0.5) * 0.12; }
  // 首の伸縮（瞬間的に伸び上がる）
  e.stretchT -= dt; if(e.stretchT<=0 && Math.random()<0.005){ e.stretchT = 0.25 + Math.random()*0.35; }
  const stretchK = e.stretchT>0 ? (0.6 + Math.sin((0.25-e.stretchT)*12.0)*0.4) : 0.0;
  if(p.neck){ p.neck.scale.y = 1.0 + e.neckStretchAmp * (wob*0.5 + stretchK); }
  // 頭の奇妙な追尾
  if(p.head){ p.head.rotation.y = Math.sin(e.t*0.65 + e.headJit + wob)*0.22; p.head.rotation.x = Math.sin(e.t*1.0 + i + wob*0.7)*0.06; }
  // 膝の過伸展（snapっぽい挙動）
  e.kneeFlipT -= dt; if(e.kneeFlipT<=0 && Math.random()<0.006){ e.kneeFlipT = 0.18 + Math.random()*0.25; }
  const flipK = e.kneeFlipT>0 ? (0.6 + Math.sin((0.25-e.kneeFlipT)*18.0)*0.4) : 0.0;
  if(p.kneeL){ p.kneeL.rotation.x += flipK*0.25; }
  if(p.kneeR){ p.kneeR.rotation.x += flipK*0.25; }
  // 微痙攣（手首/足首）
  e.spasmT -= dt; if(e.spasmT<=0 && Math.random()<0.01){ e.spasmT = 0.08 + Math.random()*0.14; }
  const spasm = e.spasmT>0 ? (Math.sin(e.t*40.0)*0.25) : 0.0;
  if(p.wristL){ p.wristL.rotation.z += spasm*0.2; }
  if(p.wristR){ p.wristR.rotation.z -= spasm*0.2; }
  if(p.ankleL){ p.ankleL.rotation.z += spasm*0.15; }
  if(p.ankleR){ p.ankleR.rotation.z -= spasm*0.15; }
  // 指のフレア（スプレー/カール）+ 微痙攣
  function updateFingers(fingers, sideSign){
    if(!Array.isArray(fingers)) return;
    const flare = 0.6 + 0.4*(0.5+0.5*Math.sin(e.t*0.9 + wob));
    for(let fi=0; fi<fingers.length; fi++){
      const f = fingers[fi];
      const phase = e.t*1.7 + fi*0.6 + wob*0.5;
      const curl = 0.3 + 0.5*(0.5+0.5*Math.sin(phase));
      const splay = (f.splayBase||0) * flare;
      if(f.base){ f.base.rotation.z = splay; }
      if(f.prox){ f.prox.rotation.x = -0.7*curl; }
      if(f.midG){ f.midG.rotation.x = -0.55*curl + spasm*0.15; }
      if(f.tipG){ f.tipG.rotation.x = -0.45*curl + spasm*0.15; }
      // 親指は少し外側へ（fi==0）
      if(fi===0 && f.base){ f.base.rotation.y += sideSign*0.15*(0.5+0.5*Math.sin(e.t*1.1 + i)); }
    }
  }
  if(p.fingersL) updateFingers(p.fingersL, +1);
  if(p.fingersR) updateFingers(p.fingersR, -1);
      // ヒップの上下バウンド
  if(p.hips){ p.hips.position.y = e.baseHipY + Math.abs(Math.sin(ph*2.0))*0.055; }
    }

  // neon flicker + occasional spark (distance-cull updates)
    const neonRange = 140;
    for(let i=0;i<neonMeshes.length;i++){
      const m = neonMeshes[i]; const c = neonCtrl[i];
      if(!inDrawChunks(m.position.x, m.position.z)){ m.visible = false; continue; }
      m.visible = true;
  const outage = (Math.random() < c.offProb*dt) ? 0.0 : 1.0;
      const wave = 0.4 + 0.6*Math.abs(Math.sin(timeElapsed*c.speed + c.jitter));
      const intensity = c.base * wave * outage;
      if(m.material && m.material.emissiveIntensity !== undefined){ m.material.emissiveIntensity = intensity; }
  if(c.light){ c.light.intensity = 0.6 * intensity; c.light.position.set(m.position.x, 1.2 + 0.2*Math.sin(timeElapsed*2.0), m.position.z); }
      // try to spark occasionally when intensity rises
      c.nextSpark -= dt;
      if(c.nextSpark <= 0 && outage>0.0 && Math.random()<0.08){
        c.nextSpark = 1.5 + Math.random()*3.0;
        spawnSparkParticles(new Vector3(m.position.x, 0.6, m.position.z));
        // play short spark sfx
        if(audioStarted) playSparkAt(m.position);
      }
    }

    // utility poles arcing (distance-cull)
    const poleRange = 160;
    for(let i=0;i<utilPoles.length;i++){
      const p = utilPoles[i];
      if(!inDrawChunks(p.head.position.x, p.head.position.z)){ p.light.visible=false; p.head.visible=false; continue; }
      p.light.visible = true; p.head.visible = true;
      const c = p.ctrl;
      const outage = (Math.random() < c.offProb*dt) ? 0.0 : 1.0;
      const wave = 0.6 + 0.4*Math.abs(Math.sin(timeElapsed*c.speed + c.jitter));
      const intensity = c.base * wave * outage;
      p.light.intensity = intensity;
      if(p.head.material) p.head.material.emissiveIntensity = intensity*0.8;
      c.nextSpark -= dt;
      if(c.nextSpark <= 0 && outage>0.0 && Math.random()<0.1){
        c.nextSpark = 1.8 + Math.random()*3.0;
        spawnSparkParticles(new Vector3(p.head.position.x, p.head.position.y, p.head.position.z));
        if(audioStarted) playSparkAt(p.head.position);
      }
    }

    // simulate spark particles
    for(let i=sparkBursts.length-1; i>=0; i--){
      const p = sparkBursts[i];
      const posAttr = p.geometry.getAttribute('position');
      const velAttr = p.geometry.getAttribute('velocity');
      const N = posAttr.count;
      p.userData.age += dt; const life = p.userData.life;
      const fade = Math.max(0, 1 - p.userData.age / life);
      if(p.material) p.material.opacity = 0.8 * fade;
      for(let j=0;j<N;j++){
        const ix = j*3;
        velAttr.array[ix+0] *= (1 - 0.9*dt); // horizontal damping
        velAttr.array[ix+2] *= (1 - 0.9*dt);
        velAttr.array[ix+1] += (-9.8) * dt; // gravity
        posAttr.array[ix+0] += velAttr.array[ix+0] * dt;
        posAttr.array[ix+1] += velAttr.array[ix+1] * dt;
        posAttr.array[ix+2] += velAttr.array[ix+2] * dt;
        // clamp to ground
        if(posAttr.array[ix+1] < 0.02){ posAttr.array[ix+1] = 0.02; velAttr.array[ix+1] *= -0.2; }
      }
      posAttr.needsUpdate = true; velAttr.needsUpdate = true;
      if(p.userData.age >= life){ scene.remove(p); sparkBursts.splice(i,1); }
    }

    // billboard the moon toward camera and keep it far
    if(moon){
      moon.lookAt(camera.position.x, camera.position.y, camera.position.z);
      const dirToMoon = new THREE.Vector3(-1, 0.5, -1).normalize();
      const baseDist = 1000;
      moon.position.copy(camera.position).addScaledVector(dirToMoon, baseDist).setY(camera.position.y + 420);
    }

    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener('resize', ()=>{ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
  window.addEventListener('resize', sizeMiniMapCanvas);
  // Interaction logic
  function tryInteract(){
    if(!highlighted) { return; }
    const ud = highlighted.userData || {};
    if(ud.interactable === 'pickup'){
      armReachT = 1.0;
      addToInventory({ kind: ud.kind, name: ud.name, color: ud.color });
  updateProgressHUD();
      const idx = interactables.indexOf(highlighted); if(idx>=0) interactables.splice(idx,1);
      if(highlighted.parent) highlighted.parent.remove(highlighted);
      highlighted = null; prompt.style.display = 'none';
      rebuildColliders();
      if(audioStarted){
        const osc = audioCtx.createOscillator(); const g = audioCtx.createGain();
        osc.type='sine'; osc.frequency.value = 880; g.gain.value = 0.0001; osc.connect(g); g.connect(audioCtx.destination);
        const t = audioCtx.currentTime; g.gain.linearRampToValueAtTime(0.06, t+0.02); g.gain.exponentialRampToValueAtTime(0.0001, t+0.25); osc.start(); osc.stop(t+0.28);
      }
    } else if(ud.interactable === 'gate'){
      if(canActivateGate()){
        // 起動演出
        if(highlighted.material){ highlighted.material.emissive = new THREE.Color(0x33ff99); highlighted.material.emissiveIntensity = 0.5; }
        // 簡易SE
        if(audioStarted){ const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='sawtooth'; o.frequency.value=320; g.gain.value=0.0001; o.connect(g); g.connect(audioCtx.destination); const t=audioCtx.currentTime; g.gain.linearRampToValueAtTime(0.08,t+0.05); g.gain.exponentialRampToValueAtTime(0.0001,t+0.7); o.start(); o.stop(t+0.75);}      
        // 脱出完了の簡易画面
        const done = document.createElement('div');
        Object.assign(done.style, { position:'fixed', inset:'0', display:'flex', alignItems:'center', justifyContent:'center', background:'rgba(0,0,0,0.8)', color:'#fff', zIndex:99999 });
        done.innerHTML = '<div style="text-align:center"><div style="font-size:24px;font-weight:800;margin-bottom:12px">脱出成功</div><div style="opacity:0.85;margin-bottom:16px">非常用シェルターが起動しました</div><button id="btn-restart" style="padding:8px 12px;border-radius:6px;border:0;background:#3b7cff;color:#fff;font-weight:600;cursor:pointer">最初からやり直す</button></div>';
        document.body.appendChild(done);
        const br = done.querySelector('#btn-restart'); if(br){ br.addEventListener('click', ()=>{ location.reload(); }); }
      }
    } else {
      armReachT = 1.0;
    }
  }

  function tryUseBattery(){
    // prefer big battery
    const use = (kind)=>{
      // スロット配列から対象スロットを検索
      let idx = -1; let it = null;
      for(let i=0;i<INVENTORY_SLOTS;i++){
        const cand = inventory[i];
        if(cand && cand.kind===kind && cand.qty>0){ idx = i; it = cand; break; }
      }
      if(idx<0 || !it) return false;
      if(kind==='battery_big'){ var add=3; } else if(kind==='battery_small'){ var add=1; } else { return false; }
      const need = batteryMaxSegments - batterySegments; if(need<=0) return false;
      const gain = Math.min(add, need);
  batterySegments += gain; it.qty -= 1; if(it.qty<=0){ inventory[idx] = null; }
      updateBatteryUI(); renderInventory();
      // feedback sound
      if(audioStarted){ const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='triangle'; o.frequency.value=520; g.gain.value=0.0001; o.connect(g); g.connect(audioCtx.destination); const t=audioCtx.currentTime; g.gain.linearRampToValueAtTime(0.06,t+0.02); g.gain.exponentialRampToValueAtTime(0.0001,t+0.25); o.start(); o.stop(t+0.28);}      
      return true;
  };
    if(use('battery_big')) return; use('battery_small');
  }
})();

  </script>
  <script>
    (function(){
      const btn = document.getElementById('fullscreen-toggle');
      const target = document.body;
      btn.addEventListener('click', ()=>{
        if(!document.fullscreenElement){
          (target.requestFullscreen || target.webkitRequestFullscreen).call(target);
        } else {
          (document.exitFullscreen || document.webkitExitFullscreen).call(document);
        }
      });
    })();
  </script>
</body>
</html>